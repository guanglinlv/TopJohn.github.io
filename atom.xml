<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[TopJohn'Blog]]></title>
  <subtitle><![CDATA[Coding的路上，至少我乐在其中...]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.xuanzhangjiong.xyz/"/>
  <updated>2015-12-30T11:27:18.000Z</updated>
  <id>http://www.xuanzhangjiong.xyz/</id>
  
  <author>
    <name><![CDATA[John]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[第一次开源贡献成功]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/12/25/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE%E6%88%90%E5%8A%9F/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/12/25/第一次开源贡献成功/</id>
    <published>2015-12-25T09:23:01.000Z</published>
    <updated>2015-12-30T11:27:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h1><p>前一阵子做项目，没少看<code>oschina-android-app</code>这个开源项目，看久了，似乎也发现了其中的一些小问题，主要的问题大概有2个：</p>
<ol>
<li><p>列表缓存的Bug，在无网络的时候，滚动到底部时，当前的页数先自加了，然而在失败的时候却未减回来，如果刻意在无网络的情况下不断上拉，会出现严重的漏页现象。</p>
</li>
<li><p>管理Activity销毁的AppManager的中销毁activity不完全，存在部分activity未销毁的情况。</p>
</li>
</ol>
<h1 id="Bug_u51FA_u73B0_u7684_u8FC7_u7A0B"><a href="#Bug_u51FA_u73B0_u7684_u8FC7_u7A0B" class="headerlink" title="Bug出现的过程"></a>Bug出现的过程</h1><h2 id="u7F13_u5B58_u5217_u8868_u6F0F_u9875_u73B0_u8C61"><a href="#u7F13_u5B58_u5217_u8868_u6F0F_u9875_u73B0_u8C61" class="headerlink" title="缓存列表漏页现象"></a>缓存列表漏页现象</h2><p>开源中国项目中的分页缓存机制的实现是在BaseListFragment中实现的.</p>
<p>首先在<code>onCreateView</code>中调用<code>initView</code>方法里的<code>requestData()</code>,如果没有网络则读取对应分页的缓存，如果有网络且不是主动下拉刷新，则判断是否为第一页，如果是第一页，则优先读取缓存，如果不是第一页，如果缓存存在切没有失效，则优先读取缓存（Wi-Fi环境下缓存时间为5分钟，其他网络环境为1小时），每个半天会自动刷新一次。</p>
<p>当列表滚动到最下面的时候当前页数自动加1，但是当请求失败的时候执行<code>executeOnLoadDataError</code>方法时，并未将当前页数减回来，导致重复下拉的时候，当前分页不断增加。当有网络加载的时候，中间漏掉n页。所以最简单的解决办法，直接减回来。<br>看似没有难度，但是这个缓存机制，我也看了好几天才理清楚其中的原理。</p>
<p>修改后的代码片段：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">executeOnLoadDataError</span><span class="params">(String <span class="keyword">error</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurrentPage == <span class="number">0</span></span><br><span class="line">            &amp;&amp; !CacheManager.isExistDataCache(getActivity(), getCacheKey())) &#123;</span><br><span class="line">        mErrorLayout.setErrorType(EmptyLayout.NETWORK_ERROR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//在无网络时，滚动到底部时，mCurrentPage先自加了，然而在失败时却</span></span><br><span class="line">      <span class="comment">//没有减回来，如果刻意在无网络的情况下上拉，可以出现漏页问题</span></span><br><span class="line">      <span class="comment">//find by TopJohn</span></span><br><span class="line">        mCurrentPage--;</span><br><span class="line"></span><br><span class="line">        mErrorLayout.setErrorType(EmptyLayout.HIDE_LAYOUT);</span><br><span class="line">        mAdapter.setState(ListBaseAdapter.STATE_NETWORK_ERROR);</span><br><span class="line">        mAdapter.notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u90E8_u5206Activity_u672A_u9500_u6BC1"><a href="#u90E8_u5206Activity_u672A_u9500_u6BC1" class="headerlink" title="部分Activity未销毁"></a>部分Activity未销毁</h2><p><code>oschina-android-app</code>这个开源项目的Activity采用AppManager这个类进行管理，内部维护了一个Activity的堆栈，采用单例模式，从而可以轻易销毁所有Activity.</p>
<p>原来的代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">  * 结束所有Activity</span><br><span class="line">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> finishAllActivity() &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, <span class="built_in">size</span> = activityStack.<span class="built_in">size</span>(); i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">null</span> != activityStack.<span class="built_in">get</span>(i)) &#123;</span><br><span class="line">           finishActivity(activityStack.<span class="built_in">get</span>(i));</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     activityStack.<span class="built_in">clear</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>先不说<code>finishActivity</code>方法有没有错，在第一次循环的时候就有 <code>break;</code>语句了，也就是说，最多也就销毁一个Activity，所以我把它注视掉。本以为问题可以轻松解决，但是发现我在使用的过程中，总是有那么几个<code>Activity</code>没有被销毁。</p>
<p>finishActivity源码:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 结束指定的Activity</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishActivity</span>(<span class="params">Activity activity</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activity != <span class="keyword">null</span> &amp;&amp; !activity.isFinishing()) &#123;</span><br><span class="line">        activityStack.remove(activity);</span><br><span class="line">        activity.finish();</span><br><span class="line">        activity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试修改了其中的代码，去猜测这个bug的由来，发现去掉<code>activity.isFinishing</code>方法就可以全部销毁，<code>activity.isFinishing</code>这个方法是判断activity是否正在被销毁，或者暂停，但是不知道为什么，某些activity会出现这个状态，从而导致判断的时候漏掉了几个activity，产生了历史遗留，所以干脆点直接去掉判断，就能完全销毁了。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>在做完一个项目，或者长时间敲代码的过程中，最好停下来，好好休整下，有空多去看看开源项目中的源码，不仅能看到别人是如何编码的，而且当发现其中的问题的时候，你也可以尝试着去修改其中的代码，为开源贡献自己的力量。</p>
<p>终于贡献了自己的处女作了,也是头一次在开源项目中的git log中看到自己的提交。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/open_source_1.jpg" alt=""></p>
<p>项目地址：<br><a href="http://git.oschina.net/oschina/android-app" target="_blank" rel="external">http://git.oschina.net/oschina/android-app</a></p>
]]></content>
    <summary type="html">
    <![CDATA[在开源中国上学习了好久了，上面的帖子博客也看了N篇，开源项目，也借鉴了不少，第一次在oschina上发起Pull Request，也希望自己为开源做点小贡献。]]>
    
    </summary>
    
      <category term="oschina-android-app" scheme="http://www.xuanzhangjiong.xyz/tags/oschina-android-app/"/>
    
      <category term="开源贡献" scheme="http://www.xuanzhangjiong.xyz/categories/%E5%BC%80%E6%BA%90%E8%B4%A1%E7%8C%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[参加腾讯Innovation Space比赛的感想]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/12/20/%E5%8F%82%E5%8A%A0%E8%85%BE%E8%AE%AFInnovation-Space%E6%AF%94%E8%B5%9B%E7%9A%84%E6%84%9F%E6%83%B3/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/12/20/参加腾讯Innovation-Space比赛的感想/</id>
    <published>2015-12-20T05:45:52.000Z</published>
    <updated>2015-12-20T08:13:28.000Z</updated>
    <content type="html"><![CDATA[<p>2015年11月26日，我和几个小伙伴带着创意在线报名了腾讯的Innovation Space 比赛，几经筛选，我们从270多个创意中，进入了总决赛。</p>
<p>12月11日，我们背上行囊奔赴上海腾讯，当然这也是第一次去腾讯，内心很激动。</p>
<p>12月11日傍晚，腾讯的HR姐姐，带我们参观了上海腾讯的腾云大厦，以及比赛团队的介绍。</p>
<p>12月12日上午，经历了半天的商业模式的洗礼。到了下午我们开始了58小时的封闭式开发。哦，忘了介绍我们的团队了：一名腾讯的产品姐姐，一名腾讯的前端大牛，一名上大的研究生学长（后端开发），以及3名浙大的骚年，一名iOS开发，一名设计，还有做Android的我。</p>
<p>我们做的产品是<code>刷脸加好友</code>,在那58小时里，我们配合的很默契，其中也出现了很多的问题：特别吐槽下腾讯的GuestWifi,慢的和乌龟一样，而且莫名地不定时地局域网无法ping通，在调试接口的时候，我们几经崩溃。最后迫于无奈，用的手机热点来，调试，是不是醉了，哈哈。</p>
<p>58小时里，我们几乎都没怎么睡觉，一直在14号中午快开始路演的时候还在调试，心好累。。。。</p>
<p>刷脸加好友的创意首先是来自于我们发现了腾讯的优图接口，我们想利用优图实现传统加好友的局限性，能够仅仅通过一张老照片，对仅仅只有一面之缘的又无法联系到的人通过社交平台添加好友，这是我们的初衷。</p>
<p>说了半天，获奖没，并没有，当路演完，评审完，我们意识到了，哦，原来商业模式也是很重要的，不仅创意要好，产品要做出来，而且要能够让投资人能够了解到创意背后的商业价值，好吧，也许我们在这方面思考欠佳。</p>
<p>但是这并不影响我对这次比赛的感受，还是很值得的，体验了58小时的封闭式开发，感受了BAT之一的大公司，了解了一个公司，认识了这么多小伙伴。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/innovation_space.png" alt="附上一张合照" title="合照"></p>
<p>项目的客户端代码已经放到我的Github上了，需要的小伙伴可以自己下载，做的比较简陋，毕竟只有58小时，希望不要见怪。</p>
<p>当然无图无真相：<br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_5.jpg?imageView2/2/w/360/h/640" alt="">    <img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_4.jpg?imageView2/2/w/360/h/640" alt=""><br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_3.jpg?imageView2/2/w/360/h/640" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_6.jpg?imageView2/2/w/360/h/640" alt=""><br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_2.jpg?imageView2/2/w/360/h/640" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_1.jpg?imageView2/2/w/360/h/640" alt=""><br><br></p>
<p>Git地址：<a href="/&#x6d;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#103;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;&#58;&#x54;&#111;&#x70;&#74;&#111;&#104;&#110;&#x2f;&#x66;&#97;&#99;&#x65;&#x53;&#x77;&#105;&#112;&#105;&#110;&#x67;&#46;&#x67;&#x69;&#116;">&#103;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109;&#58;&#x54;&#111;&#x70;&#74;&#111;&#104;&#110;&#x2f;&#x66;&#97;&#99;&#x65;&#x53;&#x77;&#105;&#112;&#105;&#110;&#x67;&#46;&#x67;&#x69;&#116;</a></p>
]]></content>
    <summary type="html">
    <![CDATA[虽然并没有获奖，但是认识了一群小伙伴，经历了，很值得...]]>
    
    </summary>
    
      <category term="生活感言" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E8%A8%80/"/>
    
      <category term="项目经历" scheme="http://www.xuanzhangjiong.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
      <category term="作品" scheme="http://www.xuanzhangjiong.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E4%BD%9C%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android技术贴总汇]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/12/19/android%E5%AD%A6%E4%B9%A0%E6%80%BB%E6%B1%87/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/12/19/android学习总汇/</id>
    <published>2015-12-19T08:12:38.000Z</published>
    <updated>2015-12-19T11:53:04.000Z</updated>
    <content type="html"><![CDATA[<p>收藏夹里积攒了好多自己喜欢的blog和帖子，是时候找个时间整理下了，方便他人学习，为他人填坑，也方便自己以后的回顾，so,let’s begin…</p>
<ul>
<li><p><a href="http://www.stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路</a>从android开发入门，到后来的进阶，stormzhang提供了许多自己宝贵的经验，值得拜读。</p>
</li>
<li><p><a href="http://tech.meituan.com/" target="_blank" rel="external">美团技术团队</a>美团在做一些技术上的分享，在国内属于领先的地位，里面有一些和移动开发相关高质量文章。</p>
</li>
<li><p><a href="http://bugly.qq.com/blog/" target="_blank" rel="external">腾讯Bugly博客</a>腾讯Bugly博客</p>
</li>
<li><p><a href="http://tools.android.com/recent" target="_blank" rel="external">Recent Changes</a>了解Android新动态，需要翻墙。</p>
</li>
<li><p><a href="http://androidweekly.net/" target="_blank" rel="external">Android Weekly</a>Android周报，英文，邮箱订阅。</p>
</li>
<li><p><a href="http://www.androidweekly.cn/" target="_blank" rel="external">Android 开发技术周报</a>国内的开发周报。</p>
</li>
<li><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="external">AndroidDevTools</a>提供了不翻墙下载Android相关工具的服务。</p>
</li>
<li><p><a href="http://android-developers.blogspot.ca/" target="_blank" rel="external">Android Blog</a>Android 官方的开发博客。</p>
</li>
<li><p><a href="http://developer.android.com/intl/zh-cn/index.html" target="_blank" rel="external">Android官网</a>官网对开发者提供了许多教程以及开发实例，坚持阅读，相信会受益匪浅。毋庸置疑，官网需要翻墙。</p>
</li>
<li><p><a href="https://github.com/pcqpcq/open-source-android-apps" target="_blank" rel="external">Android开源项目</a>提供了众多不同领域的开源项目，值得学习。</p>
</li>
<li><p><a href="http://www.jianshu.com/p/1078568e859f" target="_blank" rel="external">Android Material Design 最佳实践项目</a>对于Material Design众多组件的使用给出了详细的讲解说明，是MD入门的利器。</p>
</li>
<li><p><a href="http://v.youku.com/v_show/id_XODk2NjkwNjM2.html?f=23494296&amp;from=y1.7-1.3" target="_blank" rel="external">Android 性能模式 第一季(中字幕)</a>Google官方推出的性能优化视频，第一季。最初发布在Youtube，Google为了方便天朝人民观看，在优酷上也放了一份。</p>
</li>
<li><p><a href="http://v.youku.com/v_show/id_XMTMxNDIzODcxMg==.html?f=26016201&amp;from=y1.7-3" target="_blank" rel="external">Android 性能模式 第二季(中字幕)</a>Google官方推出的性能优化视频，第二季。</p>
</li>
<li><p><a href="http://v.youku.com/v_show/id_XMTMwMTYzNDQwMA==.html?f=25972284&amp;from=y1.7-3" target="_blank" rel="external">Android 性能模式 第三季(英字幕)</a>Google官方推出的性能优化视频，第三季。</p>
</li>
<li><p><a href="http://v.youku.com/v_show/id_XMTM1OTI3NDE2NA==.html?f=26144822&amp;from=y1.7-3" target="_blank" rel="external">Android 性能模式 第四季(英字幕)</a>Google官方推出的性能优化视频，第四季。</p>
</li>
<li><p><a href="http://hukai.me/" target="_blank" rel="external">胡凯的博客</a>胡凯大神，腾讯Android高级开发，做了许多优质的分享，发起了翻译Android Training Course的活动。</p>
</li>
<li><p><a href="http://a.codekk.com/" target="_blank" rel="external">CodeKK</a>国内Android开源领袖级的人物，博客中有许多眼前一亮的干货。</p>
</li>
<li><p><a href="http://litesuits.com/" target="_blank" rel="external">Lite Your Android</a>博主倡导极简生活，开源了一些极简概念的Android库。</p>
</li>
<li><p><a href="http://www.vmatianyu.cn/" target="_blank" rel="external">Liter’s Blog</a>这是上一条推荐项目的博主的个人博客，前辈的博文语重心长，非常诚恳。</p>
</li>
<li><p><a href="http://keeganlee.me/" target="_blank" rel="external">Keegan小钢</a>博客中又对Android动画以及项目重构的实战讲解。</p>
</li>
<li><p><a href="http://it.deepinmind.com/index.html" target="_blank" rel="external">Java基础及深入</a>非常棒的一个博客，有关Java学习的博文质量很高。</p>
</li>
<li><p><a href="http://www.itechzero.com/google-mirror-sites-collect.html" target="_blank" rel="external">Google镜像集合</a>持续更新，让你不翻墙也可以用Google搜索。</p>
</li>
<li><p><a href="http://blog.knownsec.com/Knownsec_RD_Checklist/v3.0.html" target="_blank" rel="external">知道创宇研发技能表v3.0</a>对于Programer或者Geeker来说，这个技能表是必备的。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[平时发现的优质blog和技术贴，会持续更新]]>
    
    </summary>
    
      <category term="Android进阶优质资源" scheme="http://www.xuanzhangjiong.xyz/tags/Android%E8%BF%9B%E9%98%B6%E4%BC%98%E8%B4%A8%E8%B5%84%E6%BA%90/"/>
    
      <category term="Android" scheme="http://www.xuanzhangjiong.xyz/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[柚子房东，第一个从无到有的创业项目]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/12/01/%E6%9F%9A%E5%AD%90%E6%88%BF%E4%B8%9C%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E7%9A%84%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/12/01/柚子房东，第一个从无到有的创业项目/</id>
    <published>2015-12-01T06:52:05.000Z</published>
    <updated>2015-12-21T12:57:34.000Z</updated>
    <content type="html"><![CDATA[<p>开篇先贴个网站首页先：<br><a href="http://www.inyouzi.com" target="_blank" rel="external">http://www.inyouzi.com</a></p>
<p>七月中旬，在和导师的一番交流后，我加入了<code>柚子房东</code>这个项目，其实当时还不叫这个名字，叫<code>V-house</code>，来到了苏州金鸡湖边的一个酒店和一群从事房地产的人开始了我们的创业之路。</p>
<p>记得当时，大学还刚毕业不久，便开始了长达一个多月的酒店式封闭开发。</p>
<p>7月中旬，当时产品还没有确定最终的方向，大佬们还在讨论公司走向，作为码农，我只好先开始了各种填坑工作，对各种技术进行调研。一开始，我们曾经想过用<a href="http://ionicframework.com/" target="_blank" rel="external">Ionic</a>来开发，毕竟Hybrid的开发速度比原生的会快很多。在试过水之后，发现在没有遇到重大技术障碍的时候，Hybrid的应用确实可以迅速开发出来。但是遇到在用刀第三方服务的时候就会发现虽然有些第三方服务是支持<code>Codova</code>，但是遇到那些不支持的时候，开发显然会遇到问题，当然并不是说不可行，可以用Js去调用原生的API。在体验过一些用Ionic开发的项目之后发现，用户体验太！差！了！于是乎，果断放弃了这个坑，当然，那个时候还没有出现React Native不然，我可能会…</p>
<p>言归正传，当时由于之前一直使用Eclipse进行开发，但是Eclipse的效率真的不敢恭维，Android Studio也比较成熟了，所以打算从这个项目入手，我的Android Studio填坑之路也开始了。</p>
<h1 id="u4E00_u3001_u524D_u671F_u7684_u6280_u672F_u8C03_u7814"><a href="#u4E00_u3001_u524D_u671F_u7684_u6280_u672F_u8C03_u7814" class="headerlink" title="一、前期的技术调研"></a>一、前期的技术调研</h1><p>在项目开始之前，调研了相关的第三方服务</p>
<p>短信推送服务：</p>
<ul>
<li>Submail、LeanCloud等第三方服务，相比价格，确定使用LeanCloud。</li>
</ul>
<p>由于考虑到这是一个二房东的房源管理平台，对房源图片的存储也是必不可少的，所以即使使用阿里云，使用Nginx作负载均衡，带宽也是不够的。所以需要选择一个云存储作为图床，这样的好处是可以利用第三方服务商为我们提供CDN加速，使得我们的应用服务器在较小的带宽的情况下，以较快的速度运行。</p>
<p>所以我选择了几个云存储供应商作为比较：</p>
<ul>
<li>阿里云，当然是第一反应，其次是七牛云存储，然后还有青云等等。<br>经过详细浏览后发现，阿里云虽然业务较广，但是对图片存储做的不是很细致，而且价格也比较贵，相反，七牛和青云在价格上面相对较低。我选择了七牛，因为七牛对图片的处理十分细致，使用七牛可以为以后的业务拓展奠定基础。</li>
</ul>
<h1 id="u4E8C_u3001_u7CFB_u7EDF_u6846_u67B6_u7684_u642D_u5EFA"><a href="#u4E8C_u3001_u7CFB_u7EDF_u6846_u67B6_u7684_u642D_u5EFA" class="headerlink" title="二、系统框架的搭建"></a>二、系统框架的搭建</h1><p>一个商业化的项目，当然少不了一个完善的框架做支撑，先来谈谈UI框架吧，在和我们的设计师进行沟通之后，我便提前设计开始搭建UI框架了（项目初期，我们的设计师即兼任交互又担任UI设计，后期才招了专门的UI和视觉）。<br>和一般的商业项目一样，项目UI主要是一个SplashActivity,然后主界面是4个Tab中间是一个可弹出对话框的<code>+</code>号。所以，主界面我才用了FragmentTabHost，然后里面分别是4个Fragment，里面具体细节只能在以后敲了。</p>
<p>除了UI之外，肯定少不了一些其他的工具类，例如：字符串处理类，文件处理类，缓存处理，数据库处理，设备信息，日期处理，动画处理，对话框等等一系列。这些只能靠自己平时的积累了。这个项目里的这些工具类大部分都是我以前积累的一些好的开源项目中借鉴过来的，然后在空余时间根据自己的编码风格进行修改的。我并不喜欢重复造轮子，闭门造车。</p>
<p>然后是网络请求框架了，当时我知道的2大著名的网络框架是：AsyncHttpClient和Volley。<br>我总结了一下:<br>Volley的特点主要有如下几点：</p>
<ul>
<li>能使网络通信更快，更简单，更健壮</li>
<li>Get、Post网络请求及网络图像的高效异步处理请求</li>
<li>可以对网络请求进行排序优先级管理</li>
<li>网络请求的缓存</li>
<li>多级别取消</li>
<li>和Activity声明周期的联动（Activity结束时同时取消所有网络请求）</li>
<li>使用Volley可以简化一些网络通信的开发，当然Volley不适合大数据（large payloads）和流媒体的网络请求。例如上百兆的文件、视频下载</li>
</ul>
<p>Asyn-cHttp是一款国外的开源框架。高效的网络数据请求，文件下载和上传。</p>
<ul>
<li>清晰的网络回调</li>
<li>请求使用ThreadPool，限制并发资源使用情况</li>
<li>Get/Post基于参数构建使用（RequestParams），方便</li>
<li>Multipart 文件上传，大数据上传下载</li>
<li>自动智能请求重试，优化了质量不一的移动连接</li>
<li>内置响应解析成JSON,使用JsonHttpResponseHandler</li>
<li>持久化cookie存储，保存cookie到你的应用程序的SharedPreferences</li>
<li>二进制文件（图片等）的下载，使用BinaryHttpResponseHandler</li>
</ul>
<p>思前想后，我还是决定使用<a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">loopj</a>大神的<code>android-async-http</code>，至于为什么，可能是在对两个框架进行体验的时候更喜欢<code>android-async-http</code>的参数化请求以及大文件的上传吧。其实要究其功能，并无什么大的差别。对其做了一些封装，封装了一个<code>ApiHttpClient</code>出来在里面对AsyncHttpClient使用了单例模式，因为毕竟网络请求在一个应用中十分常见，可以共用同一个实例，在类中注明了各个常量,例如Host,url前缀等等，然后对<code>Post</code>、<code>Put</code>、<code>Get</code>、<code>Delete</code>进行封装，然后对这四个方法进行多参数的重载，使得在实际使用过程中总能找到一个自己所需要的方法进行调用。</p>
<p>然后我又写了一个类，对上述这个类进行调用，根据实际需求编写不同名称的网路请求的静态方法，对<code>ApiHttpClient</code>进行封装，每个方法都将网络请求返回时回调的AsynchttpHandler作为参数放入其中。这样对任何一个网络请求都可以进行简单明了的调用了。哦，忘了说了，在这个项目中采用了<code>stateless</code>的接口设计规范，和我之前做过的项目不一样，看了一篇博客感觉这样的设计将成为以后的主流，而且确实对于一部分需要用户认证，一部分不需要用户认证的API设计的时候，确实很有优势。博客地址如下,有兴趣的可以自己去看下：<br><a href="http://www.haomou.net/2014/08/13/2014_web_token/" target="_blank" rel="external">http://www.haomou.net/2014/08/13/2014_web_token/</a><br>其实说的通俗点，就是你在第一次登录的时候服务器给你返回一个按照相应规则生成的令牌，然后之后的请求，你就可以拿着这个令牌去访问服务器了。听着好傻，不过确实很实用。我的<code>token</code>是利用Java的<code>Property</code>存到文件中的，这样下次打开应用就无需重新登录了，第一次获取了<code>token</code>之后就把<code>token</code>存到Http协议的BasicAuth中可以了。</p>
<p>还有图片缓存框架，<code>Picasso</code>、<code>UniversalImageLoader</code>、<code>KjBitmap</code>（小众，开源中国的开源实验室出品），我选的是啥，我选的是<code>UniversalImageLoader</code>，原因其实很奇葩：<br><code>Picasso</code>没怎么用过，<code>KjBitmap</code>貌似刚出来不久，勉强可以，但是使用不够灵活，重点说说<code>UniversalImageLoader</code>，大三的时候，我和同学一起合作写一个校园论坛的客户端，他负责朋友圈这一块，用了这个框架，然而还不是引入第三方包的方法，直接拷贝的源代码，还不和我说，害得我以为是他写的（太牛了），然后默默地读了好几天源代码。过了一段时间才焕然大悟，居然偷用框架！！！所以说，我对<code>UniversalImageLoader</code>相对来说更加了解，以后也会找个机会分析分析它。</p>
<p>由于大型项目UI往往十分复杂，每个Activity或者Fragment中往往会有几十个控件，如果一个一个findViewById的话，累哭，现在不是很流行注解嘛，那就用一个，<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="external">ButterKnife</a>，看过相关资料，<code>ButterKnife</code>是一个编译级的注解，所以效率应该不会很差。</p>
<h1 id="u4E09_u3001_u8001_u751F_u5E38_u8C08_uFF0C_u9002_u914D_u95EE_u9898_u5982_u4F55_u89E3_u51B3_u5462"><a href="#u4E09_u3001_u8001_u751F_u5E38_u8C08_uFF0C_u9002_u914D_u95EE_u9898_u5982_u4F55_u89E3_u51B3_u5462" class="headerlink" title="三、老生常谈，适配问题如何解决呢"></a>三、老生常谈，适配问题如何解决呢</h1><p>屏幕适配，一直是Android的十分重要的问题，看过很多关于适配的文章，其中也有许多小技巧，有的甚至使用了一套代码来实现高质量的屏幕适配。但我觉得倒不必如此，在开发中尽量使用RelativeLayout、LinearLayout，多用weight属性，现在不是还出了百分比布局嘛，尺寸使用dp、sp，对于一些通常的机型这些都不是问题，像魅族这样比较特殊的可以单独适配。</p>
<p>在这个项目中，设计师是用sketch设计的，全部采用的矢量图，站在现在看，sketch确实十分强大，是移动设计的利器啊。但是唯一美中不足的是设计师给的是iOS的设计稿，没办法，对于细节只能自己调了。sketch中的1x、1.5x、2x、3x对应的是android中的mdpi、hdpi、xhdpi、xxhdpi，想着切着么多份图apk会很大，然而现在手机的性能也不再是瓶颈，所以我只切了xxhdpi的图，虽然在低分辨率的手机中，这些图片多占了内存，但是鱼与熊掌总是不能兼得的。在后来和一些已经入职的童鞋的交谈中，得知貌似大众点评也仅仅放了xxhdpi的图，那就心安理得了。</p>
<p>在sketch中切出的3x的图在android中显示的效果还不错。</p>
<h1 id="u56DB_u3001_u6F2B_u957F_u7684_u4EE3_u7801_u4E4B_u65C5"><a href="#u56DB_u3001_u6F2B_u957F_u7684_u4EE3_u7801_u4E4B_u65C5" class="headerlink" title="四、漫长的代码之旅"></a>四、漫长的代码之旅</h1><p>之后就是，无休止的业务逻辑，拿到高保真的设计稿，然后按照一比一的实现，在UI上倒真是花了不少功夫，一会贴图吧，这里只是抒发下开发的历程，细节就不讲了。</p>
<p>开发过程中，印象比较深刻的是，有一个问题，我居然困扰了一个星期。GridView中的图片错位，如果是原生的GridView的话还好。但是我用的是需要自适应高度的网格布局，继承了GridView，导致GridView在绘制的过程中，会出现多次测量的问题，然而其中的图片又是异步加载的，2种情况的叠加导致我陷入了无限的遐想。。。</p>
<p><a href="http://www.cnblogs.com/lesliefang/p/3619223.html" target="_blank" rel="external">http://www.cnblogs.com/lesliefang/p/3619223.html</a>这篇博客中的问题和我的问题大致类似，但并不完全一样，最后脑洞大开，直接用一个Holder保存每个item现实的时候加入判断就可以了。</p>
<p>当然开发中肯定不止遇到这一个坑，一些小问题都能在<code>BaiDu</code>上找到，百度找不到，那就<code>Google</code>，一般都能在<code>stackoverflow</code>上找到，真是一个神奇的网站。</p>
<p>但是有一个问题，我至今仍未解决，就是关于<code>JSON</code>解析的。当时用阿里的<code>FastJson</code>，原因是它自称是最快的解析框架，但是在解析范型嵌套类的时候居然不定时的出错，同样的代码执行时不定时出错，不能理解。后来去GitHub上面搜了一下，果然，吐槽的人一大堆。<br><a href="https://github.com/alibaba/fastjson/issues/330" target="_blank" rel="external">https://github.com/alibaba/fastjson/issues/330</a><br>当然我可以不用范型，但是我不愿放弃这么机智的通用的套路，尝试了一下<code>Gson</code>居然可以，那我就放弃了<code>FastJson</code>。希望有大神可以替我解答一下。</p>
<p>项目里的重大事故还有就是<a href="http://www.getui.com" target="_blank" rel="external">个推</a>，当时选用个推的原因是，因为它是浙大学长开发的，那就用吧。第一次集成的时候，退出应用的时候居然收不到消息通知和透穿消息，郁闷，然后从官网找到了技术支持，绕了半天，貌似是他们那里出了点问题，问题总算解决了。</p>
<p>后来项目快做完了，在做一些细化的工作，消息通知的设置，当时测试小米的时候，惊奇地发现，按照官方文档写的代码，小米手机退出应用后居然不能接收消息通知了。瞬间不开心了，去官网浏览了一下没有解决，换了一个测试机，华为荣耀、1+手机，我去，2个都可以，退出后依然可以收到。我深深体会到了android平台的多样性，多么广阔的天空啊，啥鸟都有～～。</p>
<p>一个星期之后，又去浏览官网，发现了一个新版本记得是2.6.1，试了一下，退出后小米手机倒是可以收到推送通知了。貌似应用退出后强制重启了进程。好吧，也就是说关不了了。不知道现在2.7.0这个版本改进了没。</p>
<h1 id="u4E94_u3001_u6DF7_u6DC6"><a href="#u4E94_u3001_u6DF7_u6DC6" class="headerlink" title="五、混淆"></a>五、混淆</h1><p>之前开发，从未混淆过，以至于，在引入第三方库的时候也没有注意需要<code>-keep</code>什么，导致结束时要一下子理清楚，谈何容易，于是乎，在和朋友交谈过程中，找到了一个偷懒的办法，<a href="http://dev.360.cn/m/protect.html" target="_blank" rel="external">360加壳技术</a>，很方便，直接相当于混淆了。原本以为万事大吉了，但是后来居然要搞自动化部署，用这个加壳技术显然是行不通了。于是乎又被迫走上了<code>Proguard</code>的混淆之路了。我没有特意修改混淆规则，貌似也不简单，用的是android的混淆规则。从头一个一个理清引用的第三方库的混淆配置，一个一个写到<code>proguard-rules.pro</code>里去，写了134行。终于可以了，谢天谢地。</p>
<p>知道怎么做了，当然要想为什么了，仅仅会写，就叫不思进取。。。其实仔细想一下也不难，混淆无非就是把你源代码中的类名、方法名、参数名按照一定规则改的面目全非，让人难以阅读嘛。改了之后，比如在<code>xml</code>中使用了自定义的控件，那么在代码中经过混淆，然而<code>xml</code>中并没有修改，所以就出错了。还有在<code>JSON</code>解析的时候，一般使用框架的话大多用到了范型机制，从网络传输过来的字符串肯定是按照没有混淆的时候写的，然而混淆过了之后，想用反射去实例化一个对象，那肯定不行了咯。我的理解大概就是这样的。如果有朋友了解的更深的话，欢迎探讨。</p>
<p>最近用<code>apktool</code>尝试了下对著名的一些app的反编译，发现大多对资源也进行混淆了。越来越机智了。这里给出一篇美团技术团队的资源混淆的教程。<br><a href="http://tech.meituan.com/mt-android-resource-obfuscation.html" target="_blank" rel="external">http://tech.meituan.com/mt-android-resource-obfuscation.html</a></p>
<h1 id="u516D_u3001_u591A_u6E20_u9053_u6253_u5305"><a href="#u516D_u3001_u591A_u6E20_u9053_u6253_u5305" class="headerlink" title="六、多渠道打包"></a>六、多渠道打包</h1><p>最近app要上线了，要发不到各大应用商店，我们的运营和我说，需要统计从每个渠道的下载量，和活跃度。我隐约想到了好像有个多渠道打包，也看过类似的文章，但是一直没有机会实践一下。那就乘着这个项目实践一下吧。</p>
<p>我用的是友盟统计，貌似还有个百度统计，发现用了Android Studio之后什么都变的方便了，在build.gradle中<code>productFlavors</code>里写相应的渠道名就可以替换<code>Manifest</code>中的相应渠道名了，总之不难，然后根据不同的渠道生成不同的apk名字就可以了，一天搞定。</p>
<h1 id="u4E03_u3001_u603B_u7ED3"><a href="#u4E03_u3001_u603B_u7ED3" class="headerlink" title="七、总结"></a>七、总结</h1><p>陆陆续续从苏州到宁波，开发了4个多月，差不多一套成熟的开发套路，我也走了一遍了，其中收获了很多，用了很多第三方的服务，视野也变开阔了，Git的使用频率变多了，GitHub逛的次数变多了，翻墙的频率是更多了。对Android的认识也更加进了一步。项目告一段落，是时候静心好好沉淀一下了。。。<br>貌似小米应用商店已经上线了：<br><a href="http://app.mi.com/detail/121871?ref=search" target="_blank" rel="external">http://app.mi.com/detail/121871?ref=search</a></p>
<p>团队介绍：<br><a href="http://www.inyouzi.com" target="_blank" rel="external">http://www.inyouzi.com</a></p>
<p>忘了最后的截图了，毕竟无图无真相:<br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_1.jpg?imageView2/2/w/240/h/427" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_2.jpg?imageView2/2/w/240/h/427" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_3.jpg?imageView2/2/w/240/h/427" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_4.jpg?imageView2/2/w/240/h/427" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_5.jpg?imageView2/2/w/240/h/427" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_6.jpg?imageView2/2/w/240/h/427" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_7.jpg?imageView2/2/w/240/h/427" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_8.jpg?imageView2/2/w/240/h/427" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/inyouzi_9.jpg?imageView2/2/w/240/h/427" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[柚子房东这个项目，从7月中旬开始定需求，设计，开发，也经历了4个多月了，v1.0也算是上线了，来谈谈这几个月的感想吧。]]>
    
    </summary>
    
      <category term="创业项目，一个字“累”" scheme="http://www.xuanzhangjiong.xyz/tags/%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E2%80%9C%E7%B4%AF%E2%80%9D/"/>
    
      <category term="作品" scheme="http://www.xuanzhangjiong.xyz/categories/%E4%BD%9C%E5%93%81/"/>
    
      <category term="项目经历" scheme="http://www.xuanzhangjiong.xyz/categories/%E4%BD%9C%E5%93%81/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单例模式]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/11/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/11/01/单例模式/</id>
    <published>2015-11-01T11:37:54.000Z</published>
    <updated>2015-12-30T12:54:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E00_u3001_u5355_u4F8B_u6A21_u5F0F_u7684_u5B9A_u4E49"><a href="#u4E00_u3001_u5355_u4F8B_u6A21_u5F0F_u7684_u5B9A_u4E49" class="headerlink" title="一、单例模式的定义"></a>一、单例模式的定义</h1><p>单例模式在Web开发和Android开发中，实在是太常见了，抽空把各种单例模式都整理一遍。</p>
<p>首先，单例模式（Singleton Pattern）是一个比较简单的模式，其定义如下：</p>
<p>Ensure a class has only one instance,and provide a global point of access to it.(确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。)</p>
<p>Singleton类称为单例类，通过使用private的构造函数确保了在一个应用中只产生一个实例，并且是自行实例化的（在Singleton中自己使用new Singleton()。单例模式的通用源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="comment">//限制产生多个对象</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过该方法获得实例对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//类中其他方法，尽量是static</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="u5355_u4F8B_u6A21_u5F0F_u7684_u5E94_u7528"><a href="#u5355_u4F8B_u6A21_u5F0F_u7684_u5E94_u7528" class="headerlink" title="单例模式的应用"></a>单例模式的应用</h1><h2 id="u5355_u4F8B_u6A21_u5F0F_u7684_u4F18_u70B9"><a href="#u5355_u4F8B_u6A21_u5F0F_u7684_u4F18_u70B9" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h2><ul>
<li>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。</li>
<li>由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）。</li>
<li>单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</li>
<li>单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。</li>
</ul>
<h2 id="u5355_u4F8B_u6A21_u5F0F_u7684_u7F3A_u70B9"><a href="#u5355_u4F8B_u6A21_u5F0F_u7684_u7F3A_u70B9" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h2><ul>
<li>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何意义的，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。</li>
<li>单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</li>
<li>单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</li>
</ul>
<h2 id="u5355_u4F8B_u6A21_u5F0F_u7684_u4F7F_u7528_u573A_u666F"><a href="#u5355_u4F8B_u6A21_u5F0F_u7684_u4F7F_u7528_u573A_u666F" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h2><p>在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“不良反应”，可以采用单例模式，具体的场景如下：</p>
<ul>
<li>要求生成唯一序列号的环境；</li>
<li>在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并且保证是线程安全的；</li>
<li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；</li>
<li>需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，页可以直接声明为static的方式）。</li>
</ul>
<h2 id="u5355_u4F8B_u6A21_u5F0F_u7684_u6CE8_u610F_u4E8B_u9879"><a href="#u5355_u4F8B_u6A21_u5F0F_u7684_u6CE8_u610F_u4E8B_u9879" class="headerlink" title="单例模式的注意事项"></a>单例模式的注意事项</h2><p>首先，在高并发情况下，请注意单例模式的线程同步问题。单例模式有几种不同的实现方式，上面的例子不会出现多个实例的情况，但是下面的情况：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//限制产生多个对象</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过该方法获得实例对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;</span><br><span class="line">      singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该单例模式在低并发的情况下尚不会出现问题，若系统压力增大，并发量增加时则可能在内存中出现多个实例，破坏了最初的预期。</p>
<p>解决线程不安全的方法有很多，可以在<code>getSingleton</code>方法前加<code>synchronized</code>关键字，也可以在<code>getSingleton</code>方法内增加<code>synchronized</code>来实现。</p>
<p>其次，需要考虑对象的复制情况。在Java中，对象默认是不可以被复制的，若实现了Cloneable接口，并实现了clone方法，则可以直接通过对象复制方式创建一个新对象，对象复制是不用调用类构造方法，因此即使是私有的构造方法，对象仍然可以被复制，在一般情况下，类复制的情况不需要考虑，很少会出现一个单例类会主动要求被复制的情况，解决该问题的最好方法就是单例类不要实现Cloneable接口。</p>
]]></content>
    <summary type="html">
    <![CDATA[单例模式在Android中应用的十分广泛，今天抽空整理一下。]]>
    
    </summary>
    
      <category term="单例模式" scheme="http://www.xuanzhangjiong.xyz/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://www.xuanzhangjiong.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MarkDown语法练习]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/10/10/MarkDown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/10/10/MarkDown语法练习/</id>
    <published>2015-10-10T08:51:41.000Z</published>
    <updated>2015-12-20T10:45:33.000Z</updated>
    <content type="html"><![CDATA[<p>写一些最简单，最实用的，下面的都是我用来写博客的。</p>
<h1 id="u5F3A_u8C03"><a href="#u5F3A_u8C03" class="headerlink" title="强调"></a>强调</h1><p>星号*与下划线_都可以，单是斜体，双是粗体，符号可跨行，符号可加空格</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span>单星号是斜体<span class="keyword">*</span></span><br></pre></td></tr></table></figure>
<p><em>单星号是斜体</em></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span>双星号是粗体<span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure>
<p><strong>双星号是粗体</strong></p>
<h1 id="u5206_u5272_u7EBF"><a href="#u5206_u5272_u7EBF" class="headerlink" title="分割线"></a>分割线</h1><p>三个或更多_*，必须单独一行，可含空格</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="u5F15_u7528"><a href="#u5F15_u7528" class="headerlink" title="引用"></a>引用</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">翻译成html就是<span class="tag">&lt;<span class="title">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="title">blockquote</span>&gt;</span>，符号&gt;后的空格可不要</span><br><span class="line">&gt;引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用</p>
</blockquote>
<p>注意使用空行结束</p>
<p>内层符号前的空格必须要</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br><span class="line"> <span class="prompt">&gt;&gt;</span>引用中的引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用</p>
<blockquote>
<p>引用中的引用</p>
</blockquote>
</blockquote>
<h1 id="u6807_u9898"><a href="#u6807_u9898" class="headerlink" title="标题"></a>标题</h1><p>Setext方式<br>三个=-或更多</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">大标题</span><br><span class="line">===</span></span><br></pre></td></tr></table></figure>
<h1 id="u5927_u6807_u9898"><a href="#u5927_u6807_u9898" class="headerlink" title="大标题"></a>大标题</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">小标题</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure>
<h2 id="u5C0F_u6807_u9898"><a href="#u5C0F_u6807_u9898" class="headerlink" title="小标题"></a>小标题</h2><p>标题Atx方式<br>符号#必须加空格</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 一级标题</span></span><br><span class="line"><span class="preprocessor">## 二级标题</span></span><br><span class="line"><span class="preprocessor">### 三级标题</span></span><br><span class="line"><span class="preprocessor">#### 四级标题</span></span><br><span class="line"><span class="preprocessor">##### 五级标题</span></span><br><span class="line"><span class="preprocessor">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<h1 id="u65E0_u5E8F_u5217_u8868"><a href="#u65E0_u5E8F_u5217_u8868" class="headerlink" title="无序列表"></a>无序列表</h1><p>符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！</span><br></pre></td></tr></table></figure>
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！</li>
</ul>
<h1 id="u6709_u5E8F_u5217_u8868"><a href="#u6709_u5E8F_u5217_u8868" class="headerlink" title="有序列表"></a>有序列表</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 有序列表</span><br><span class="line"><span class="number">2.</span> 有序列表</span><br><span class="line"><span class="number">3.</span> 有序列表</span><br><span class="line"><span class="number">4.</span> 有序列表</span><br></pre></td></tr></table></figure>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<h1 id="u5D4C_u5957_u5217_u8868"><a href="#u5D4C_u5957_u5217_u8868" class="headerlink" title="嵌套列表"></a>嵌套列表</h1><p>+*-可循环使用，但符号之后的空格不能少，次级列表中符号之前的空格也不能少</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 嵌套列表</span><br><span class="line"></span> + 嵌套列表</span><br><span class="line"> + 嵌套列表</span><br><span class="line">  -<span class="ruby"> 嵌套列表</span><br><span class="line"></span>   * 嵌套列表</span><br><span class="line">-<span class="ruby"> 嵌套列表</span></span><br></pre></td></tr></table></figure>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
<li>嵌套列表</li>
</ul>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
</ul>
</li>
</ul>
</li>
<li>嵌套列表</li>
</ul>
<h1 id="u6587_u5B57_u8D85_u94FE_uFF1AInline_u65B9_u5F0F"><a href="#u6587_u5B57_u8D85_u94FE_uFF1AInline_u65B9_u5F0F" class="headerlink" title="文字超链：Inline方式"></a>文字超链：Inline方式</h1><p>Tooltips可省略</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[]</span><span class="list">(<span class="keyword">http://blog.xuanzhangjiong.xyz</span>)</span></span><br></pre></td></tr></table></figure>
<p><a href="http://blog.xuanzhangjiong.xyz" target="_blank" rel="external"></a></p>
<h1 id="u56FE_u7247_u8D85_u94FE"><a href="#u56FE_u7247_u8D85_u94FE" class="headerlink" title="图片超链"></a>图片超链</h1><p>多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="link_label">GitHub Mark</span>](<span class="link_url">http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png "GitHub Mark"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Mark" title="GitHub Mark"></p>
<h1 id="u7D22_u5F15_u8D85_u94FE_uFF1AReference_u65B9_u5F0F"><a href="#u7D22_u5F15_u8D85_u94FE_uFF1AReference_u65B9_u5F0F" class="headerlink" title="索引超链：Reference方式"></a>索引超链：Reference方式</h1><p>索引，1 2可以是任意字符</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="link_label">Stepway's Notes</span>][<span class="link_reference">1</span>]</span><br><span class="line">![<span class="link_label">GitHub Octocat</span>][<span class="link_reference">2</span>]</span><br><span class="line">[<span class="link_reference">1</span>]:<span class="link_url">http://blog.xuanzhangjiong.xyz</span></span><br><span class="line">[<span class="link_reference">2</span>]:<span class="link_url">http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png</span></span><br></pre></td></tr></table></figure>
<p><a href="http://blog.xuanzhangjiong.xyz" target="_blank" rel="external">TopJohn’s Blog</a><br><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png" alt="GitHub Octocat"></p>
<h1 id="u81EA_u52A8_u94FE_u63A5"><a href="#u81EA_u52A8_u94FE_u63A5" class="headerlink" title="自动链接"></a>自动链接</h1><p>尖括号</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">http:</span><span class="comment">//blog.xuanzhangjiong.xyz&gt;</span></span><br><span class="line">&lt;<span class="string">http:</span><span class="comment">//TopJohn.github.io&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h1><p>行内代码 使用符号`</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">`v</span>al s = <span class="string">"hello Markdown"</span><span class="escape">`</span><br><span class="line"></span><span class="escape">``</span>val s = <span class="string">"hello Markdown"</span> 需要显示(<span class="escape">`)</span><span class="escape">``</span></span><br></pre></td></tr></table></figure>
<p><code>val s = &quot;hello Markdown&quot;</code><br><code>val s = &quot;hello Markdown&quot; 需要显示(`)</code></p>
<h1 id="u6BB5_u843D_u4EE3_u7801"><a href="#u6BB5_u843D_u4EE3_u7801" class="headerlink" title="段落代码"></a>段落代码</h1><p>每行文字前加4个空格或者1个Tab，并用空行开始</p>
<p>这是一个普通段落：<br>    这是一个代码区块。<br>    这是一个代码区块。</p>
<h1 id="hexo_u4EE3_u7801"><a href="#hexo_u4EE3_u7801" class="headerlink" title="hexo代码"></a>hexo代码</h1><p>可指定编程语言，{ % % }代表左右大括号</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:php] [url] [link text]%&#125;</span><br><span class="line">  <span class="variable">$word</span> = <span class="string">'hello'</span></span><br><span class="line">  echo <span class="variable">$word</span>;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><figcaption><span>php</span><a href="http://blog.xuanzhangjiong.xyz" target="_blank" rel="external">link php</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$word</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$word</span>;</span><br></pre></td></tr></table></figure>
<h1 id="u6CE8_u91CA"><a href="#u6CE8_u91CA" class="headerlink" title="注释"></a>注释</h1><p>用html的注释<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对当前编辑文件(.md)的注释 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u8F6C_u4E49_u5B57_u7B26"><a href="#u8F6C_u4E49_u5B57_u7B26" class="headerlink" title="转义字符"></a>转义字符</h1><p>Markdown中的转义字符为\，转义的有：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="command">\\</span> 反斜杠</span><br><span class="line"><span class="command">\`</span> 反引号</span><br><span class="line"><span class="command">\*</span> 星号</span><br><span class="line"><span class="command">\_</span> 下划线</span><br><span class="line"><span class="command">\&#123;</span><span class="command">\&#125;</span> 大括号</span><br><span class="line"><span class="command">\[</span><span class="command">\]</span> 中括号</span><br><span class="line"><span class="command">\(</span><span class="command">\)</span> 小括号</span><br><span class="line"><span class="command">\#</span> 井号</span><br><span class="line"><span class="command">\+</span> 加号</span><br><span class="line"><span class="command">\-</span> 减号</span><br><span class="line"><span class="command">\.</span> 英文句号</span><br><span class="line"><span class="command">\!</span> 感叹号</span><br></pre></td></tr></table></figure></p>
<h1 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h1><p>文本中可直接用html标签，但是要前后加上空行。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">'text</span>'&gt;</span><br></pre></td></tr></table></figure></p>
<input type="text">

<h1 id="one_more_thing_uFF1A_u8868_u683C"><a href="#one_more_thing_uFF1A_u8868_u683C" class="headerlink" title="one more thing：表格"></a>one more thing：表格</h1><p>Markdown的扩展语法，hexo不支持<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Tables        </span>|<span class="string"> Are           </span>|<span class="string"> Cool  </span>|</span><br><span class="line">|<span class="string"> ------------- </span>|<span class="string">:-------------:</span>|<span class="string"> -----:</span>|</span><br><span class="line">|<span class="string"> col 3 is      </span>|<span class="string"> right-aligned </span>|<span class="string"> $1600 </span>|</span><br><span class="line">|<span class="string"> col 2 is      </span>|<span class="string"> centered      </span>|<span class="string">   $12 </span>|</span><br><span class="line">|<span class="string"> zebra stripes </span>|<span class="string"> are neat      </span>|<span class="string">    $1 </span>|</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h1 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="http://ibruce.info/2013/11/26/markdown/" target="_blank" rel="external">Markdown简明语法</a></li>
<li><a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown语法说明</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[MarkDown语法现在越来越常见了，Github的Readme，SegmentFault、Coding、OSChina、简书都要用...]]>
    
    </summary>
    
      <category term="码农必备常识" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%A0%81%E5%86%9C%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
    
      <category term="MarkDown" scheme="http://www.xuanzhangjiong.xyz/categories/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java-注解浅析]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/09/10/Java-%E6%B3%A8%E8%A7%A3%E6%B5%85%E6%9E%90/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/09/10/Java-注解浅析/</id>
    <published>2015-09-10T07:18:03.000Z</published>
    <updated>2015-12-21T08:46:32.000Z</updated>
    <content type="html"><![CDATA[<p>有很多开源的库都利用注解来简化代码提升开发效率。</p>
<p>下面，我就来谈谈我学习Java注解的一点点看法。</p>
<p>本文简单介绍下 Annotation 示例、概念及作用、分类、自定义、解析，并对几个 Android 开源库 Annotation 原理进行简析。</p>
<h1 id="1-Annotation_u793A_u4F8B"><a href="#1-Annotation_u793A_u4F8B" class="headerlink" title="1.Annotation示例"></a>1.Annotation示例</h1><p>Override Annotation</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Retrofit Annotation</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GET</span>(<span class="string">"/users/&#123;username&#125;"</span>)</span><br><span class="line">User <span class="function">getUser</span>(<span class="variable">@Path</span>(<span class="string">"username"</span>) String username);</span><br></pre></td></tr></table></figure>
<p>Butter Knife Annotation</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">InjectView(R.id.user)</span> EditText username</span>;</span><br></pre></td></tr></table></figure>
<p>ActiveAndroid Annotation</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Column(<span class="keyword">name</span> = “<span class="keyword">Name</span><span class="string">") public String name;</span></span><br></pre></td></tr></table></figure>
<p>Retrofit 为符合 RESTful 规范的网络请求框架<br>Butter Knife 为 View 及事件等依赖注入框架<br>Active Android 为 ORM 框架</p>
<h1 id="2-_Annotation__u6982_u5FF5_u53CA_u4F5C_u7528"><a href="#2-_Annotation__u6982_u5FF5_u53CA_u4F5C_u7528" class="headerlink" title="2. Annotation 概念及作用"></a>2. Annotation 概念及作用</h1><blockquote>
<p>An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate.</p>
</blockquote>
<p>能够添加到Java源代码的语法元数据。类、方法、变量、参数、包都可以被注解，可用来将信息元数据与程序元素进行关联。Annotation 中文常译为“注解”。</p>
<h2 id="2-2__u4F5C_u7528"><a href="#2-2__u4F5C_u7528" class="headerlink" title="2.2 作用"></a>2.2 作用</h2><p>a. 标记，用于告诉编译器一些信息<br>b. 编译时动态处理，如动态生成代码<br>c. 运行时动态处理，如得到注解信息<br>这里的三个作用实际对应着后面自定义 Annotation 时说的 @Retention 三种值分别表示的 Annotation</p>
<h1 id="3-_Annotation__u5206_u7C7B"><a href="#3-_Annotation__u5206_u7C7B" class="headerlink" title="3. Annotation 分类"></a>3. Annotation 分类</h1><h2 id="3-1__u6807_u51C6_Annotation_uFF0COverride_2C_Deprecated_2C_SuppressWarnings"><a href="#3-1__u6807_u51C6_Annotation_uFF0COverride_2C_Deprecated_2C_SuppressWarnings" class="headerlink" title="3.1 标准 Annotation，Override, Deprecated, SuppressWarnings"></a>3.1 标准 Annotation，Override, Deprecated, SuppressWarnings</h2><p>标准 Annotation 是指 Java 自带的几个 Annotation，上面三个分别表示重写函数，不鼓励使用(有更好方式、使用有风险或已不在维护)，忽略某项 Warning</p>
<h2 id="3-2__u5143_Annotation_uFF0C@Retention_2C_@Target_2C_@Inherited_2C_@Documented"><a href="#3-2__u5143_Annotation_uFF0C@Retention_2C_@Target_2C_@Inherited_2C_@Documented" class="headerlink" title="3.2 元 Annotation，@Retention, @Target, @Inherited, @Documented"></a>3.2 元 Annotation，@Retention, @Target, @Inherited, @Documented</h2><p>元 Annotation 是指用来定义 Annotation 的 Annotation，在后面 Annotation 自定义部分会详细介绍含义</p>
<h2 id="3-3__u81EA_u5B9A_u4E49_Annotation"><a href="#3-3__u81EA_u5B9A_u4E49_Annotation" class="headerlink" title="3.3 自定义 Annotation"></a>3.3 自定义 Annotation</h2><p>自定义 Annotation 表示自己根据需要定义的 Annotation，定义时需要用到上面的元 Annotation<br>这里是一种分类而已，也可以根据作用域分为源码时、编译时、运行时 Annotation，后面在自定义 Annotation 时会具体介绍</p>
<h1 id="4-_Annotation__u81EA_u5B9A_u4E49"><a href="#4-_Annotation__u81EA_u5B9A_u4E49" class="headerlink" title="4. Annotation 自定义"></a>4. Annotation 自定义</h1><h2 id="4-1__u8C03_u7528"><a href="#4-1__u8C03_u7528" class="headerlink" title="4.1 调用"></a>4.1 调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@MethodInfo</span>(</span><br><span class="line">        author = “trinea.cn+android<span class="annotation">@gmail</span>.com”,</span><br><span class="line">        date = <span class="string">"2014/02/14"</span>,</span><br><span class="line">        version = <span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"trinea"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是调用自定义 Annotation——MethodInfo 的示例。<br>MethodInfo Annotation 作用为给方法添加相关信息，包括 author、date、version。</p>
<h2 id="4-2__u5B9A_u4E49"><a href="#4-2__u5B9A_u4E49" class="headerlink" title="4.2 定义"></a>4.2 定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Documented</span></span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="annotation">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> MethodInfo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "trinea@gmail.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">date</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">version</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是 MethodInfo 的实现部分<br>(1). 通过 @interface 定义，注解名即为自定义注解名<br>(2). 注解配置参数名为注解类的方法名，且：<br>a. 所有方法没有方法体，没有参数没有修饰符，实际只允许 public &amp; abstract 修饰符，默认为 public，不允许抛异常<br>b. 方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组<br>c. 若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation<br>(3). 可以加 default 表示默认值</p>
<h2 id="4-3__u5143_Annotation"><a href="#4-3__u5143_Annotation" class="headerlink" title="4.3 元 Annotation"></a>4.3 元 Annotation</h2><p>@Documented 是否会保存到 Javadoc 文档中<br>@Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings<br>@Target 可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有<br>@Inherited 是否可以被继承，默认为 false</p>
<h1 id="5-_Annotation__u89E3_u6790"><a href="#5-_Annotation__u89E3_u6790" class="headerlink" title="5. Annotation 解析"></a>5. Annotation 解析</h1><h2 id="5-1__u8FD0_u884C_u65F6_Annotation__u89E3_u6790"><a href="#5-1__u8FD0_u884C_u65F6_Annotation__u89E3_u6790" class="headerlink" title="5.1 运行时 Annotation 解析"></a>5.1 运行时 Annotation 解析</h2><p>(1) 运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">method</span>.<span class="title">getAnnotation</span><span class="params">(AnnotationName.<span class="keyword">class</span>)</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">method</span>.<span class="title">getAnnotations</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">method</span>.<span class="title">isAnnotationPresent</span><span class="params">(AnnotationName.<span class="keyword">class</span>)</span>;</span></span><br></pre></td></tr></table></figure>
<p>其他 @Target 如 Field，Class 方法类似<br>getAnnotation(AnnotationName.class) 表示得到该 Target 某个 Annotation 的信息，因为一个 Target 可以被多个 Annotation 修饰<br>getAnnotations() 则表示得到该 Target 所有 Annotation<br>isAnnotationPresent(AnnotationName.class) 表示该 Target 是否被某个 Annotation 修饰</p>
<p>(2) 解析示例如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> cls = <span class="type">Class</span>.forName(<span class="string">"cn.trinea.java.test.annotation.App"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Method</span> <span class="keyword">method</span> : cls.getMethods()) &#123;</span><br><span class="line">            <span class="type">MethodInfo</span> methodInfo = <span class="keyword">method</span>.getAnnotation(</span><br><span class="line"><span class="type">MethodInfo</span>.class);</span><br><span class="line">            <span class="keyword">if</span> (methodInfo != null) &#123;</span><br><span class="line">                <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"method name:"</span> + <span class="keyword">method</span>.getName());</span><br><span class="line">                <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"method author:"</span> + methodInfo.author());</span><br><span class="line">                <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"method version:"</span> + methodInfo.version());</span><br><span class="line">                <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"method date:"</span> + methodInfo.date());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (<span class="type">ClassNotFoundException</span> e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以之前自定义的 MethodInfo 为例，利用 Target（这里是 Method）getAnnotation 函数得到 Annotation 信息，然后就可以调用 Annotation 的方法得到响应属性值</p>
<h2 id="5-2__u7F16_u8BD1_u65F6_Annotation__u89E3_u6790"><a href="#5-2__u7F16_u8BD1_u65F6_Annotation__u89E3_u6790" class="headerlink" title="5.2 编译时 Annotation 解析"></a>5.2 编译时 Annotation 解析</h2><p>(1) 编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，甴编译器自动解析。需要做的<br>a. 自定义类集成自 AbstractProcessor<br>b. 重写其中的 process 函数<br>这块很多同学不理解，实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理</p>
<p>(2) 假设 MethodInfo 的 @Retention 为 CLASS，解析示例如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SupportedAnnotationTypes</span>(&#123; <span class="string">"cn.trinea.java.test.annotation.MethodInfo"</span> &#125;)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MethodInfoProcessor</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AbstractProcessor</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public boolean process(<span class="type">Set</span>&lt;? <span class="keyword">extends</span> <span class="type">TypeElement</span>&gt; annotations, <span class="type">RoundEnvironment</span> env) &#123;</span><br><span class="line">        <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; map = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">TypeElement</span> te : annotations) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Element</span> element : env.getElementsAnnotatedWith(te)) &#123;</span><br><span class="line">                <span class="type">MethodInfo</span> methodInfo = element.getAnnotation(<span class="type">MethodInfo</span>.<span class="keyword">class</span>);</span><br><span class="line">                map.put(element.getEnclosingElement().toString(), methodInfo.author());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SupportedAnnotationTypes 表示这个 Processor 要处理的 Annotation 名字。<br>process 函数中参数 annotations 表示待处理的 Annotations，参数 env 表示当前或是之前的运行环境<br>process 函数返回值表示这组 annotations 是否被这个 Processor 接受，如果接受后续子的 rocessor 不会再对这个 Annotations 进行处理</p>
<h1 id="6-__u51E0_u4E2A_Android__u5F00_u6E90_u5E93_Annotation__u539F_u7406_u7B80_u6790"><a href="#6-__u51E0_u4E2A_Android__u5F00_u6E90_u5E93_Annotation__u539F_u7406_u7B80_u6790" class="headerlink" title="6. 几个 Android 开源库 Annotation 原理简析"></a>6. 几个 Android 开源库 Annotation 原理简析</h1><h2 id="6-1_Annotation__u2014_Retrofit"><a href="#6-1_Annotation__u2014_Retrofit" class="headerlink" title="6.1 Annotation — Retrofit"></a>6.1 Annotation — Retrofit</h2><p>(1) 调用<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GET</span>(<span class="string">"/users/&#123;username&#125;"</span>)</span><br><span class="line">User <span class="function">getUser</span>(<span class="variable">@Path</span>(<span class="string">"username"</span>) String username);</span><br></pre></td></tr></table></figure></p>
<p>(2) 定义<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(<span class="function"><span class="keyword">METHOD</span>)</span><br><span class="line">@<span class="title">Retention</span><span class="params">(RUNTIME)</span></span><br><span class="line">@<span class="title">RestMethod</span><span class="params">("GET")</span></span><br><span class="line"><span class="title">public</span> @<span class="title">interface</span> <span class="title">GET</span> <span class="comment">&#123;</span><br><span class="line">  String value();</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>从定义可看出 Retrofit 的 Get Annotation 是运行时 Annotation，并且只能用于修饰 Method</p>
<p>(3) 原理</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> parseMethodAnnotations() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Annotation</span> methodAnnotation : <span class="keyword">method</span>.getAnnotations()) &#123;</span><br><span class="line">    <span class="type">Class</span>&lt;? extends <span class="type">Annotation</span>&gt; annotationType = methodAnnotation.annotationType();</span><br><span class="line">    <span class="type">RestMethod</span> methodInfo = null;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Annotation</span> innerAnnotation : annotationType.getAnnotations()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">RestMethod</span>.class == innerAnnotation.annotationType()) &#123;</span><br><span class="line">            methodInfo = (<span class="type">RestMethod</span>) innerAnnotation;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RestMethodInfo.java 的 parseMethodAnnotations 方法如上，会检查每个方法的每个 Annotation， 看是否被 RestMethod 这个 Annotation 修饰的 Annotation 修饰，这个有点绕，就是是否被 GET、DELETE、POST、PUT、HEAD、PATCH 这些 Annotation 修饰，然后得到 Annotation 信息，在对接口进行动态代理时会掉用到这些 Annotation 信息从而完成调用。</p>
<h2 id="6-2_Annotation__u2014_Butter_Knife"><a href="#6-2_Annotation__u2014_Butter_Knife" class="headerlink" title="6.2 Annotation — Butter Knife"></a>6.2 Annotation — Butter Knife</h2><p>(1) 调用</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">InjectView(R.id.user)</span></span><br><span class="line">EditText username</span>;</span><br></pre></td></tr></table></figure>
<p>(2) 定义</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(CLASS)</span><br><span class="line"><span class="annotation">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> InjectView &#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可看出 Butter Knife 的 InjectView Annotation 是编译时 Annotation，并且只能用于修饰属性</p>
<p>(3) 原理</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? <span class="keyword">extends</span> TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Map&lt;TypeElement, ViewInjector&gt; targetClassMap = findAndParseTargets(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, ViewInjector&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">        TypeElement typeElement = entry.getKey();</span><br><span class="line">        ViewInjector viewInjector = entry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JavaFileObject jfo = filer.createSourceFile(viewInjector.getFqcn(), typeElement);</span><br><span class="line">            Writer writer = jfo.openWriter();</span><br><span class="line">            writer.write(viewInjector.brewJava());</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">error</span>(typeElement, <span class="string">"Unable to write injector for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ButterKnifeProcessor.java 的 process 方法如上，编译时，在此方法中过滤 InjectView 这个 Annotation 到 targetClassMap 后，会根据 targetClassMap 中元素生成不同的 class 文件到最终的 APK 中，然后在运行时调用 ButterKnife.inject(x) 函数时会到之前编译时生成的类中去找。</p>
<h2 id="6-3_Annotation__u2014_ActiveAndroid"><a href="#6-3_Annotation__u2014_ActiveAndroid" class="headerlink" title="6.3 Annotation — ActiveAndroid"></a>6.3 Annotation — ActiveAndroid</h2><p>(1) 调用</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Column</span>(name = “Name")</span><br><span class="line">public String name;</span><br></pre></td></tr></table></figure>
<p>(2) 定义</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> Column &#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可看出 ActiveAndroid 的 Column Annotation 是运行时 Annotation，并且只能用于修饰属性。</p>
<p>(3) 原理</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Field</span> idField = getIdField(type);</span><br><span class="line">mColumnNames.put(idField, mIdName);</span><br><span class="line"></span><br><span class="line">List&lt;<span class="keyword">Field</span>&gt; fields = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">Field</span>&gt;(ReflectionUtils.getDeclaredColumnFields(type));</span><br><span class="line">Collections.reverse(fields);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">Field</span> <span class="keyword">field</span> : fields) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">field</span>.isAnnotationPresent(Column.class)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Column columnAnnotation = <span class="keyword">field</span>.getAnnotation(Column.class);</span><br><span class="line">        String columnName = columnAnnotation.name();</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(columnName)) &#123;</span><br><span class="line">            columnName = <span class="keyword">field</span>.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mColumnNames.put(<span class="keyword">field</span>, columnName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TableInfo.java 的构造函数如上，运行时，得到所有行信息并存储起来用来构件表信息。</p>
<p>并没有深入了解这些框架的原理，只是粗浅的介绍，以后有时间再来沉下心研究。</p>
]]></content>
    <summary type="html">
    <![CDATA[见惯了Android中的annotation，以及各种资源注解的框架，却没有深入了解其中的原理，深表惭愧...]]>
    
    </summary>
    
      <category term="注解" scheme="http://www.xuanzhangjiong.xyz/tags/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="Java" scheme="http://www.xuanzhangjiong.xyz/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus浅析]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/09/03/EventBus%E6%B5%85%E6%9E%90/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/09/03/EventBus浅析/</id>
    <published>2015-09-03T02:24:11.000Z</published>
    <updated>2015-12-20T02:59:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E00_u3001_u6982_u8FF0_u53CA_u57FA_u672C_u6982_u5FF5"><a href="#u4E00_u3001_u6982_u8FF0_u53CA_u57FA_u672C_u6982_u5FF5" class="headerlink" title="一、概述及基本概念"></a>一、概述及基本概念</h1><p>EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。</p>
<p>作为一个消息总线，有三个主要的元素：</p>
<ul>
<li>Event：事件</li>
<li>Subscriber：事件订阅者，接收特定的事件</li>
<li>Publisher:事件发布者，用于通知Subscriber有事件发生</li>
</ul>
<h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>Event可以是任意类型的对象。</p>
<h2 id="Subscriber"><a href="#Subscriber" class="headerlink" title="Subscriber"></a>Subscriber</h2><p>在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync这四个，这个和ThreadMode有关，后面再说。</p>
<h2 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h2><p>可以在任意线程任意位置发送事件，直接调用EventBus的<code>post(Object)</code>方法，可以自己实例化EventBus对象，但一般使用默认的单例就好了：<code>EventBus.getDefault()</code>，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</p>
<h2 id="ThreadMode"><a href="#ThreadMode" class="headerlink" title="ThreadMode"></a>ThreadMode</h2><p>前面说了，Subscriber函数的名字只能是那4个，因为每个事件订阅函数都是和一个<code>ThreadMode</code>相关联的，ThreadMode指定了会调用的函数。有以下四个ThreadMode：</p>
<ul>
<li>PostThread：事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。</li>
<li>MainThread:事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。</li>
<li>BackgroundThread：事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，事件处理是在后台线程，但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。</li>
<li>Async：事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。</li>
</ul>
<p>根据事件订阅都函数名称的不同，会使用不同的ThreadMode，比如果在后台线程加载了数据想在UI线程显示，订阅者只需把函数命名为onEventMainThread。</p>
<h1 id="u4E8C_u3001_u7B80_u5355_u4F7F_u7528"><a href="#u4E8C_u3001_u7B80_u5355_u4F7F_u7528" class="headerlink" title="二、简单使用"></a>二、简单使用</h1><p>基本的使用步骤就是如下4步。</p>
<p>定义事件类型：<br><code>public class MyEvent {}</code><br>定义事件处理方法：<br><code>public void onEventMainThread</code><br>注册订阅者：<br><code>EventBus.getDefault().register(this)</code><br>发送事件：<br><code>EventBus.getDefault().post(new MyEvent())</code></p>
<h1 id="u4E09_u3001_u5B9E_u73B0"><a href="#u4E09_u3001_u5B9E_u73B0" class="headerlink" title="三、实现"></a>三、实现</h1><p>EventBus使用方法很简单，但用一个东西，如果不了解它的实现用起来心里总是没底，万一出问题咋办都不知道，所以还是研究一下它的实现，肯定要Read the fucking Code。其实主要是<code>EventBus</code>这一个类，在看看Code时需要了解几个概念与成员，了解了这些后实现就很好理解了。</p>
<p>EventType：onEvent函数中的参数，表示事件的类型<br>Subscriber：订阅源，即调用register注册的对象，这个对象内包含onEvent函数<br>SubscribMethod：<code>Subscriber</code>内某一特定的onEvent方法，内部成员包含一个<code>Method</code>类型的method成员表示这个onEvent方法，一个<code>ThreadMode</code>成员threadMode表示事件的处理线程，一个<code>Class&lt;?&gt;</code>类型的eventType成员表示事件的类型<code>EventType</code>。<br>Subscription，表示一个订阅对象，包含订阅源<code>Subscriber</code>，订阅源中的某一特定方法<code>SubscribMethod</code>，这个订阅的优先级<code>priopity</code></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventType -&gt; List&lt;Subscription&gt;，事件到订阅对象之间的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriber -&gt; List&lt;EventType&gt;，订阅源到它订阅的的所有事件类型的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;<span class="keyword">Class</span>&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stickEvent事件，后面会看到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventType -&gt; List&lt;? extends EventType&gt;，事件到它的父事件列表的映射。即缓存一个类的所有父类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, List&lt;<span class="keyword">Class</span>&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;<span class="keyword">Class</span>&lt;?&gt;, List&lt;<span class="keyword">Class</span>&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="u56DB_u3001_u6CE8_u518C_u4E8B_u4EF6_uFF1Aregister"><a href="#u56DB_u3001_u6CE8_u518C_u4E8B_u4EF6_uFF1Aregister" class="headerlink" title="四、注册事件：register"></a>四、注册事件：register</h1><p>通过<code>EventBus.getDefault().register</code>方法可以向<code>EventBus</code>注册来订阅事件，<code>register</code>有很多种重载形式，但大都被标记为<code>Deprecated</code>了，所以还是不用为好，前面说了事件处理方法都是以<em>onEvent</em>开头，其实是可以通过register方法修改的，但相应的方法被废弃了，还是不要用了，就用默认的<em>onEvent</em>，除下废弃的register方法，还有以下4个<strong>public</strong>的<code>register</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span>(subscriber, defaultMethodName, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span>(subscriber, defaultMethodName, <span class="literal">false</span>, priority);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSticky</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span>(subscriber, defaultMethodName, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSticky</span><span class="params">(Object subscriber, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span>(subscriber, defaultMethodName, <span class="literal">true</span>, priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这4个方法都调用了同一个方法：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">private</span> synchronized void register(Object <span class="keyword">subscriber, </span><span class="keyword">String </span>methodName, <span class="keyword">boolean </span>sticky, int priority) &#123;</span><br><span class="line">    List&lt;<span class="keyword">SubscriberMethod&gt; </span><span class="keyword">subscriberMethods </span>= <span class="keyword">subscriberMethodFinder.findSubscriberMethods(subscriber.getClass(),</span><br><span class="line"></span><span class="label">methodName</span>)<span class="comment">;</span></span><br><span class="line">    for (<span class="keyword">SubscriberMethod </span><span class="keyword">subscriberMethod </span>: <span class="keyword">subscriberMethods) </span>&#123;</span><br><span class="line">        <span class="keyword">subscribe(subscriber, </span><span class="keyword">subscriberMethod, </span>sticky, priority)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数就是订阅源，第二个参数就是用到指定方法名约定的，默认为<em>onEvent</em>开头，说默认是其实是可以通过参数修改的，但前面说了，方法已被废弃，最好不要用。第三个参数表示是否是<em>Sticky Event</em>，第4个参数是优先级，这两个后面再说。</p>
<p>在上面这个方法中，使用了一个叫<code>SubscriberMethodFinder</code>的类，通过其<code>findSubscriberMethods</code>方法找到了一个<code>SubscriberMethod</code>列表，前面知道了<code>SubscriberMethod</code>表示Subcriber内一个onEvent方法，可以看出来<code>SubscriberMethodFinder</code>类的作用是在Subscriber中找到所有以methodName（即默认的onEvent）开头的方法，每个找到的方法被表示为一个<code>SubscriberMethod</code>对象。</p>
<p><code>SubscriberMethodFinder</code>就不再分析了，但有两点需要知道：</p>
<p>所有事件处理方法<strong>必需是<code>public void</code>类型</strong>的，并且只有一个参数表示<em>EventType</em>。<br><code>findSubscriberMethods</code>不只查找<em>Subscriber</em>内的事件处理方法，<strong>同时还会查到它的继承体系中的所有基类中的事件处理方法</strong>。<br>找到<em>Subscriber</em>中的所有事件处理方法后，会对每个找到的方法（表示为<code>SubscriberMethod</code>对象）调用<code>subscribe</code>方法注册。<code>subscribe</code>方法干了三件事：</p>
<p>根据<code>SubscriberMethod</code>中的<em>EventType</em>类型将<code>Subscribtion</code>对象存放在<code>subscriptionsByEventType</code>中。建立<em>EventType</em>到<em>Subscription</em>的映射，每个事件可以有多个订阅者。<br>根据<code>Subscriber</code>将<code>EventType</code>存放在<code>typesBySubscriber</code>中，建立<em>Subscriber</em>到<em>EventType</em>的映射，每个Subscriber可以订阅多个事件。<br>如果是<em>Sticky</em>类型的订阅者，直接向它发送上个保存的事件（如果有的话）。<br>通过<em>Subscriber</em>到<em>EventType</em>的映射，我们就可以很方便地使一个Subscriber取消接收事件，通过<em>EventType</em>到<em>Sucscribtion</em>的映射，可以方便地将相应的事件发送到它的每一个订阅者。</p>
<h1 id="u4E94_u3001post_u4E8B_u4EF6"><a href="#u4E94_u3001post_u4E8B_u4EF6" class="headerlink" title="五、post事件"></a>五、post事件</h1><p>直接调用<code>EventBus.getDefault().post(Event)</code>就可以发送事件，根据Event的类型就可以发送到相应事件的订阅者。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span>(<span class="params">Object <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.<span class="keyword">get</span>();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(<span class="keyword">event</span>);</span><br><span class="line">    <span class="keyword">if</span> (postingState.isPosting) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到post内使用了<code>PostingThreadState</code>的对象，并且是<code>ThreadLocal</code>，来看<code>PostingThreadState</code>的定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="literal">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">Object</span>&gt;();</span><br><span class="line">    boolean isPosting;</span><br><span class="line">    boolean isMainThread;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    <span class="built_in">Object</span> event;</span><br><span class="line">    boolean canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是有个成员<code>eventQueue</code>，由于是ThreadLocal，所以结果就是，每个线程有一个<code>PostingThreadState</code>对象，这个对象内部有一个事件的队列，并且有一个成员<code>isPosting</code>表示现在是否正在派发事件，当发送事件开始时，会依次取出队列中的事件发送出去，如果正在派发事件，那么post直接把事件加入队列后返回，还有个成员<code>isMainThread</code>，这个成员在实际派发事件时会用到，在<code>postSingleEvent</code>中会用到。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> postSingleEvent(Object event, PostingThreadState postingState) <span class="keyword">throws</span> Error &#123;</span><br><span class="line">    <span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Object&gt; eventClass = event.getClass();</span><br><span class="line">    List&lt;<span class="keyword">Class</span>&lt;?&gt;&gt; eventTypes = findEventTypes(eventClass); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> countTypes = eventTypes.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">Class</span>&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            subscriptions = subscriptionsByEventType.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread); <span class="comment">// 4</span></span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                    postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                    postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            subscriptionFound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        <span class="keyword">if</span> (eventClass != NoSubscriberEvent.<span class="keyword">class</span> &amp;&amp; eventClass != SubscriberExceptionEvent.<span class="keyword">class</span>) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下<code>postSingleEvent</code>这个函数，首先看第一点，调用了<code>findEventTypes</code>这个函数，代码不帖了，这个函数的应用就是，把这个类的类对象、实现的接口及父类的类对象存到一个List中返回.</p>
<p>接下来进入第二步，遍历第一步中得到的List，对List中的每个类对象（即事件类型）执行第三步操作，即找到这个事件类型的所有订阅者向其发送事件。可以看到，<strong>当我们Post一个事件时，这个事件的父事件（事件类的父类的事件）也会被Post，所以如果有个事件订阅者接收Object类型的事件，那么它就可以接收到所有的事件</strong>。</p>
<p>还可以看到，实际是通过第四步中的<code>postToSubscription</code>来发送事件的，在发送前把事件及订阅者存入了<code>postingState</code>中。再来看<code>postToSubscription</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span>(<span class="params">Subscription subscription, Object <span class="keyword">event</span>, boolean isMainThread</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> PostThread:</span><br><span class="line">        invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MainThread:</span><br><span class="line">        <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">            invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mainThreadPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BackgroundThread:</span><br><span class="line">        <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">            backgroundPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Async:</span><br><span class="line">        asyncPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就用到<code>ThreadMode</code>了：</p>
<ul>
<li>如果是PostThread，直接执行</li>
<li>如果是MainThread，判断当前线程，如果本来就是UI线程就直接执行，否则加入<code>mainThreadPoster</code>队列</li>
<li>如果是后台线程，如果当前是UI线程，加入<code>backgroundPoster</code>队列，否则直接执行</li>
<li>如果是Async，加入<code>asyncPoster</code>队列</li>
</ul>
<h1 id="u516D_u3001BackgroundPoster"><a href="#u516D_u3001BackgroundPoster" class="headerlink" title="六、BackgroundPoster"></a>六、BackgroundPoster</h1><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!executorRunning) &#123;</span><br><span class="line">            executorRunning = <span class="keyword">true</span>;</span><br><span class="line">            EventBus.executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，其实就是，待发送的事件被封装成了<code>PendingPost</code>对象，<code>PendingPostQueue</code>是一个<code>PendingPost</code>对象的队列，当<code>enqueue</code>时就把这个事件放到队列中，<code>BackgroundPoster</code>其实就是一个Runnable对象，当<code>enqueue</code>时，如果这个Runnable对象当前没被执行，就将<code>BackgroundPoster</code>加入EventBus中的一个线程池中，当<code>BackgroundPoster</code>被执行时，会依次取出队列中的事件进行派发。当长时间无事件时<code>BackgroundPoster</code>所属的线程被会销毁，下次再Post事件时再创建新的线程。</p>
<h1 id="u4E03_u3001HandlerPoster"><a href="#u4E03_u3001HandlerPoster" class="headerlink" title="七、HandlerPoster"></a>七、HandlerPoster</h1><p><code>mainThreadPoster</code>是一个<code>HandlerPoster</code>对象，<code>HandlerPoster</code>继承自<code>Handler</code>，构造函数中接收一个<code>Looper</code>对象，当向<code>HandlerPoster</code> enqueue事件时，会像<code>BackgroundPoster</code>一样把这个事件加入队列中， 只是如果当前没在派发消息就向自身发送Message</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span>(<span class="params">Subscription subscription, Object <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, <span class="keyword">event</span>);</span><br><span class="line">    synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">            handlerActive = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>handleMessage</code>中会依次取出队列中的消息交由<code>EventBus</code>直接调用事件处理函数，而<code>handleMessage</code>执行所在的线程就是构造函数中传进来的<code>Looper</code>所属的线程，在<code>EventBus</code>中构造<code>mainThreadPoster</code>时传进来的是MainLooper，所以会在UI线程中执行。</p>
<h1 id="u516B_u3001AsyncPoster"><a href="#u516B_u3001AsyncPoster" class="headerlink" title="八、AsyncPoster"></a>八、AsyncPoster</h1><p><code>AsyncPoster</code>就简单了，把每个事件都加入线程池中处理</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span>(<span class="params">Subscription subscription, Object <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, <span class="keyword">event</span>);</span><br><span class="line">    queue.enqueue(pendingPost);</span><br><span class="line">    EventBus.executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u4E5D_u3001Stick_Event"><a href="#u4E5D_u3001Stick_Event" class="headerlink" title="九、Stick Event"></a>九、Stick Event</h1><p>通过<code>registerSticky</code>可以注册Stick事件处理函数，前面我们知道了，无论是<code>register</code>还是<code>registerSticky</code>最后都会调用<code>Subscribe</code>函数，在<code>Subscribe</code>中有这么一段代码：</p>
<p>也就是会根据事件类型从<code>stickyEvents</code>中查找是否有对应的事件，如果有，直接发送这个事件到这个订阅者。而这个事件是什么时候存起来的呢，同<code>register</code>与<code>registerSticky</code>一样，和<code>post</code>一起的还有一个<code>postSticky</code>函数：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">    <span class="keyword">Object</span> stickyEvent;</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        stickyEvent = stickyEvents.<span class="built_in">get</span>(eventType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">        <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span></span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当通过<code>postSticky</code>发送一个事件时，这个类型的事件的最后一次事件会被缓存起来，当有订阅者通过<code>registerSticky</code>注册时，会把之前缓存起来的这个事件直接发送给它。</p>
<h1 id="u4E8B_u4EF6_u4F18_u5148_u7EA7priority"><a href="#u4E8B_u4EF6_u4F18_u5148_u7EA7priority" class="headerlink" title="事件优先级priority"></a>事件优先级priority</h1><p><code>register</code>的函数重载中有一个可以指定订阅者的优先级，我们知道<code>EventBus</code>中有一个事件类型到List<subscription>的映射，在这个映射中，所有的Subscription是按priority排序的，这样当post事件时，优先级高的会先得到机会处理事件。</subscription></p>
<p>优先级的一个应用就事，高优先级的事件处理函数可以终于事件的传递，通过<code>cancelEventDelivery</code>方法，但有一点需要注意，<code>这个事件的ThreadMode必须是PostThread</code>，并且只能终于它在处理的事件。</p>
<p>缺点<br>无法进程间通信，如果一个应用内有多个进程的话就没办法了</p>
<p>注意事项及要点<br>同一个onEvent函数不能被注册两次，所以不能在一个类中注册同时还在父类中注册<br>当Post一个事件时，这个事件类的父类的事件也会被Post。<br>Post的事件无Subscriber处理时会Post <code>NoSubscriberEvent</code>事件，当调用Subscriber失败时会Post <code>SubscriberExceptionEvent</code>事件。</p>
<h1 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h1><p><code>EventBus</code>中还有个Util包，主要作用是可以通过<code>AsyncExecutor</code>执行一个Runnable，通过内部的RunnableEx(可以搜索异常的Runnable)当Runnable抛出异常时通过<code>EventBus</code>发消息显示错误对话框。</p>
]]></content>
    <summary type="html">
    <![CDATA[有空学习了一下EventBus,希望下个项目中可以试用下...]]>
    
    </summary>
    
      <category term="异步事件处理" scheme="http://www.xuanzhangjiong.xyz/tags/%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
      <category term="Android" scheme="http://www.xuanzhangjiong.xyz/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用Git命令清单]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/09/01/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/09/01/常用Git命令清单/</id>
    <published>2015-09-01T13:07:23.000Z</published>
    <updated>2015-12-19T13:48:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/常用Git命令清单_1.jpg" alt=""></p>
<p>敲了N遍Git命令，还是很多记住住，今天看了一篇别人总结的Git命令，敲一遍，练练手吧。</p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/常用Git命令清单_2.png" alt=""><br><br></p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h1 id="u4E00_u3001_u65B0_u5EFA_u4EE3_u7801_u5E93"><a href="#u4E00_u3001_u65B0_u5EFA_u4EE3_u7801_u5E93" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="keyword">clone</span> <span class="title">[url</span>]</span><br></pre></td></tr></table></figure>
<h1 id="u4E8C_u3001_u914D_u7F6E"><a href="#u4E8C_u3001_u914D_u7F6E" class="headerlink" title="二、配置"></a>二、配置</h1><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line"><span class="variable">$ </span>git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line"><span class="variable">$ </span>git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line"><span class="variable">$ </span>git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="u4E09_u3001_u589E_u52A0_uFF0F_u5220_u9664_u6587_u4EF6"><a href="#u4E09_u3001_u589E_u52A0_uFF0F_u5220_u9664_u6587_u4EF6" class="headerlink" title="三、增加／删除文件"></a>三、增加／删除文件</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line"><span class="variable">$ </span>git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="variable">$ </span>git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="variable">$ </span>git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="variable">$ </span>git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="variable">$ </span>git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<h1 id="u56DB_u3001_u4EE3_u7801_u63D0_u4EA4"><a href="#u56DB_u3001_u4EE3_u7801_u63D0_u4EA4" class="headerlink" title="四、代码提交"></a>四、代码提交</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git <span class="operator"><span class="keyword">commit</span> -<span class="keyword">m</span> [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git <span class="keyword">commit</span> [file1] [file2] ... -<span class="keyword">m</span> [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次<span class="keyword">commit</span>之后的变化，直接到仓库区</span><br><span class="line">$ git <span class="keyword">commit</span> -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git <span class="keyword">commit</span> -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的<span class="keyword">commit</span>，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次<span class="keyword">commit</span>的提交信息</span><br><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend -m [message]</span></span><br><span class="line"></span><br><span class="line"># 重做上一次<span class="keyword">commit</span>，并包括指定文件的新变化</span><br><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend [file1] [file2] ...</span></span></span><br></pre></td></tr></table></figure>
<h1 id="u4E94_u3001_u5206_u652F"><a href="#u4E94_u3001_u5206_u652F" class="headerlink" title="五、分支"></a>五、分支</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line"><span class="variable">$ </span>git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="variable">$ </span>git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="variable">$ </span>git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="variable">$ </span>git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="variable">$ </span>git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="variable">$ </span>git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="variable">$ </span>git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line"><span class="variable">$ </span>git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="variable">$ </span>git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line"><span class="variable">$ </span>git push origin --delete [branch-name]</span><br><span class="line"><span class="variable">$ </span>git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
<h1 id="u516D_u3001_u6807_u7B7E"><a href="#u516D_u3001_u6807_u7B7E" class="headerlink" title="六、标签"></a>六、标签</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line"></span><br><span class="line"><span class="title"># 新建一个tag</span>在当前commit</span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [<span class="operator">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [<span class="operator">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [<span class="operator">tag</span>]</span><br></pre></td></tr></table></figure>
<h1 id="u4E03_u3001_u67E5_u770B_u4FE1_u606F"><a href="#u4E03_u3001_u67E5_u770B_u4FE1_u606F" class="headerlink" title="七、查看信息"></a>七、查看信息</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line"><span class="variable">$ </span>git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line"><span class="variable">$ </span>git log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="variable">$ </span>git log --stat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="variable">$ </span>git log --follow [file]</span><br><span class="line"><span class="variable">$ </span>git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="variable">$ </span>git log -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="variable">$ </span>git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff <span class="constant">HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="variable">$ </span>git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="variable">$ </span>git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="variable">$ </span>git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="variable">$ </span>git reflog</span><br></pre></td></tr></table></figure>
<h1 id="u516B_u3001_u8FDC_u7A0B_u540C_u6B65"><a href="#u516B_u3001_u8FDC_u7A0B_u540C_u6B65" class="headerlink" title="八、远程同步"></a>八、远程同步</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line"><span class="variable">$ </span>git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line"><span class="variable">$ </span>git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="variable">$ </span>git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="variable">$ </span>git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] --all</span><br></pre></td></tr></table></figure>
<h1 id="u4E5D_u3001_u64A4_u9500"><a href="#u4E5D_u3001_u64A4_u9500" class="headerlink" title="九、撤销"></a>九、撤销</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个<span class="operator"><span class="keyword">commit</span>的指定文件到工作区</span><br><span class="line">$ git checkout [<span class="keyword">commit</span>] [<span class="keyword">file</span>]</span><br><span class="line"></span><br><span class="line"># 恢复上一个<span class="keyword">commit</span>的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次<span class="keyword">commit</span>保持一致，但工作区不变</span><br><span class="line">$ git <span class="keyword">reset</span> [<span class="keyword">file</span>]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次<span class="keyword">commit</span>保持一致</span><br><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard</span></span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定<span class="keyword">commit</span>，同时重置暂存区，但工作区不变</span><br><span class="line">$ git <span class="keyword">reset</span> [<span class="keyword">commit</span>]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的<span class="keyword">HEAD</span>为指定<span class="keyword">commit</span>，同时重置暂存区和工作区，与指定<span class="keyword">commit</span>一致</span><br><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard [commit]</span></span><br><span class="line"></span><br><span class="line"># 重置当前<span class="keyword">HEAD</span>为指定<span class="keyword">commit</span>，但保持暂存区和工作区不变</span><br><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--keep [commit]</span></span><br><span class="line"></span><br><span class="line"># 新建一个<span class="keyword">commit</span>，用来撤销指定<span class="keyword">commit</span></span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [<span class="keyword">commit</span>]</span></span><br></pre></td></tr></table></figure>
<h1 id="u5341_u3001_u5176_u4ED6"><a href="#u5341_u3001_u5176_u4ED6" class="headerlink" title="十、其他"></a>十、其他</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line"><span class="variable">$ </span>git archive</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[看到别人写的挺好的，拿来敲一边，就当回顾总结吧，哈哈，太机智了...]]>
    
    </summary>
    
      <category term="码农必备常识" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%A0%81%E5%86%9C%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
    
      <category term="Git" scheme="http://www.xuanzhangjiong.xyz/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git Flow简介]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/08/09/Git-Flow%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/08/09/Git-Flow简介/</id>
    <published>2015-08-09T08:37:14.000Z</published>
    <updated>2015-12-09T09:31:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5173_u4E8E"><a href="#u5173_u4E8E" class="headerlink" title="关于"></a>关于</h1><p>git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。<br>这里，我介绍下它的简单用法。<br>当然，我也只会这么一点点小技巧。</p>
<h1 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h1><p>第一步当然，你必须要有一个git环境咯，我就不啰嗦了。<br>Mac下，有2种安装方式：<br>Homebrew:</p>
<p><code>brew install git-flow</code></p>
<p>Macports:</p>
<p><code>port install git-flow</code></p>
<p>没有上面两个包管理的童鞋自行GitHub吧。</p>
<h1 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h1><p>为了自定义你的项目，Git flow需要初始化过程。<br>初始化<br>使用 git-flow，从初始化一个现有的 git 库内开始:</p>
<p><code>git flow init</code></p>
<p>你必须回答几个关于分支的命名约定的问题。<br>建议使用默认值。</p>
<h1 id="u7279_u6027"><a href="#u7279_u6027" class="headerlink" title="特性"></a>特性</h1><p>为即将发布的版本开发新功能特性。<br>这通常只存在开发者的库中。</p>
<h2 id="u589E_u52A0_u65B0_u7279_u6027"><a href="#u589E_u52A0_u65B0_u7279_u6027" class="headerlink" title="增加新特性"></a>增加新特性</h2><p>新特性的开发是基于 ‘develop’ 分支的。<br>通过下面的命令开始开发新特性：</p>
<p><code>git flow feature start MYFEATURE</code></p>
<p>这个操作创建了一个基于’develop’的特性分支，并切换到这个分支之下。</p>
<h2 id="u5B8C_u6210_u65B0_u7279_u6027"><a href="#u5B8C_u6210_u65B0_u7279_u6027" class="headerlink" title="完成新特性"></a>完成新特性</h2><p>完成开发新特性。这个动作执行下面的操作。<br>合并 MYFEATURE 分支到 ‘develop’<br>删除这个新特性分支<br>切换回 ‘develop’ 分支</p>
<p><code>git flow feature finish MYFEATURE</code></p>
<h2 id="u53D1_u5E03_u65B0_u7279_u6027"><a href="#u53D1_u5E03_u65B0_u7279_u6027" class="headerlink" title="发布新特性"></a>发布新特性</h2><p>你是否合作开发一项新特性？<br>发布新特性分支到远程服务器，所以，其它用户也可以使用这分支。</p>
<p><code>git flow feature publish MYFEATURE</code></p>
<h2 id="u53D6_u5F97_u4E00_u4E2A_u53D1_u5E03_u7684_u65B0_u7279_u6027_u5206_u652F"><a href="#u53D6_u5F97_u4E00_u4E2A_u53D1_u5E03_u7684_u65B0_u7279_u6027_u5206_u652F" class="headerlink" title="取得一个发布的新特性分支"></a>取得一个发布的新特性分支</h2><p>取得其它用户发布的新特性分支，并签出远程的变更。</p>
<p><code>git flow feature pull MYFEATURE</code></p>
<h1 id="u4F5C_u4E00_u4E2Arelease_u7248_u672C"><a href="#u4F5C_u4E00_u4E2Arelease_u7248_u672C" class="headerlink" title="作一个release版本"></a>作一个release版本</h1><p>支持一个新的用于生产环境的发布版本。<br>允许修正小问题，并为发布版本准备元数据。</p>
<h2 id="u5F00_u59CB_u51C6_u5907release_u7248_u672C"><a href="#u5F00_u59CB_u51C6_u5907release_u7248_u672C" class="headerlink" title="开始准备release版本"></a>开始准备release版本</h2><p>开始准备release版本，使用 git flow release 命令.<br>它从 ‘develop’ 分支开始创建一个 release 分支。</p>
<p><code>git flow release start RELEASE [BASE]</code></p>
<p>你可以选择提供一个 [BASE]参数，即提交记录的 sha-1 hash 值，来开启动 release 分支. 这个提交记录的 sha-1 hash 值必须是’develop’ 分支下的。<br>创建 release 分支之后立即发布允许其它用户向这个 release 分支提交内容是个明智的做法。命令十分类似发布新特性：</p>
<p><code>git flow release publish RELEASE</code></p>
<p>(你可以通过 <code>git flow release track RELEASE</code>命令签出 release 版本的远程变更)</p>
<h2 id="u5B8C_u6210release_u7248_u672C"><a href="#u5B8C_u6210release_u7248_u672C" class="headerlink" title="完成release版本"></a>完成release版本</h2><p>完成 release 版本是一个大 git 分支操作。它执行下面几个动作：<br>归并 release 分支到 ‘master’ 分支<br>用 release 分支名打 Tag<br>归并 release 分支到 ‘develop’<br>移除 release 分支</p>
<p><code>git flow release finish RELEASE</code></p>
<h1 id="u7D27_u6025_u4FEE_u590D"><a href="#u7D27_u6025_u4FEE_u590D" class="headerlink" title="紧急修复"></a>紧急修复</h1><p>紧急修复来自这样的需求：生产环境的版本处于一个不预期状态，需要立即修正。<br>有可能是需要修正 master 分支上某个 TAG 标记的生产版本。</p>
<h2 id="u5F00_u59CBgit_flow_u7D27_u6025_u4FEE_u590D"><a href="#u5F00_u59CBgit_flow_u7D27_u6025_u4FEE_u590D" class="headerlink" title="开始git flow紧急修复"></a>开始git flow紧急修复</h2><p>像其它 git flow 命令一样, 紧急修复分支开始自：</p>
<p><code>git flow hotfix start VERSION [BASENAME]</code></p>
<p>VERSION 参数标记着修正版本。你可以从 [BASENAME]开始，[BASENAME]为finish release时填写的版本号</p>
<h2 id="u5B8C_u6210_u7D27_u6025_u4FEE_u590D"><a href="#u5B8C_u6210_u7D27_u6025_u4FEE_u590D" class="headerlink" title="完成紧急修复"></a>完成紧急修复</h2><p>当完成紧急修复分支，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。</p>
<p><code>git flow hotfix finish VERSION</code></p>
]]></content>
    <summary type="html">
    <![CDATA[简化Git操作的神器]]>
    
    </summary>
    
      <category term="码农必备常识" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%A0%81%E5%86%9C%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
    
      <category term="Git" scheme="http://www.xuanzhangjiong.xyz/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[偶遇Git]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/07/29/%E5%81%B6%E9%81%87Git/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/07/29/偶遇Git/</id>
    <published>2015-07-29T11:26:41.000Z</published>
    <updated>2015-12-09T08:42:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u5410_u69FD"><a href="#u5410_u69FD" class="headerlink" title="吐槽"></a>吐槽</h1><p>说起Git，在很久以前就认识它，但是仅仅是知道它的存在，却从未和它交流过。</p>
<p>本科的时候，一直使用svn，而且是TortoiseGit，就是那只传说中的小乌龟，可视化的界面，导致我从来不用bash。</p>
<p>前段时间，跟着导师做一个创业项目，在做前期准备的时候，一句你们用过Git嘛，我的学生Git是一项必备技能。顿时好尴尬，只好硬着头皮说学过一点。然后就是不停地看各种blog。</p>
<p>前前后后也学习了一段时间，来写写自己学习Git的理解吧。</p>
<h1 id="u4E09_u79CD_u72B6_u6001"><a href="#u4E09_u79CD_u72B6_u6001" class="headerlink" title="三种状态"></a>三种状态</h1><p>首先要理解你的本地仓库由git维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是缓存区（Index）它像个缓存区，临时保存你的改动；最后是HEAD，指向你最近一次提交后的结果。</p>
<blockquote>
<p>WorkingDirectory Index HEAD 三大状态，对理解Git工作原理很有帮助。</p>
</blockquote>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/git_1.jpg" alt="三种状态" title="三种状态"></p>
<h1 id="u68C0_u51FA_u4ED3_u5E93"><a href="#u68C0_u51FA_u4ED3_u5E93" class="headerlink" title="检出仓库"></a>检出仓库</h1><p>执行如下命令以创建一个本地仓库的克隆版本<br><code>git clone /path/to/repository</code><br>如果是远端服务器上的仓库，你的命令会是这个样子：<br><code>git clone username@host:/path/to/repository</code></p>
<h1 id="u6DFB_u52A0_u4E0E_u63D0_u4EA4"><a href="#u6DFB_u52A0_u4E0E_u63D0_u4EA4" class="headerlink" title="添加与提交"></a>添加与提交</h1><p>你可以计划改动（把它们添加到缓存区），使用如下命令：<br><code>git add &lt;filename&gt;</code><br><code>add *</code><br><code>add .</code><br>这是git基本工作流程的第一步；使用如下命令以实际提交改动：<br><code>git commit -m&quot;代码提交信息&quot;</code><br>现在，你的改动已经提交到了HEAD，但是还没到你的远端仓库。</p>
<h1 id="u63A8_u9001_u6539_u52A8"><a href="#u63A8_u9001_u6539_u52A8" class="headerlink" title="推送改动"></a>推送改动</h1><p>你的改动现在已经在本地仓库的HEAD中了。执行如下命令以将这些改动提交到远端仓库：<br><code>git push origin master</code><br>可以把master换成你想要推送的任何分支。</p>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<br><code>git remote add origin &lt;server&gt;</code><br>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
<h1 id="u5206_u652F"><a href="#u5206_u652F" class="headerlink" title="分支"></a>分支</h1><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。<br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/git_2.jpg" alt=""><br>创建一个叫做“feature_x”的分支，并且换过去：<br><code>git checkout -b feature_x</code><br>切换回主分支：<br><code>git checkout master</code><br>再把新建的分支删掉:<br><code>git branch -d feature_x</code><br>除非你将分支推送到远端仓库，不然该分支就是不为他人所见的：<br><code>git push origin &lt;branch&gt;</code></p>
<h1 id="u66F4_u65B0_u4E0E_u5408_u5E76"><a href="#u66F4_u65B0_u4E0E_u5408_u5E76" class="headerlink" title="更新与合并"></a>更新与合并</h1><p>要更新你的本地仓库至最新改动，执行：<br><code>git pull</code><br>以在你的工作目录中获取（fetch）并合并（merge）远端的改动。<br>要合并其他分支到你的当前分支（例如master），执行：<br><code>git merge &lt;branch&gt;</code><br>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致冲突（conflicts）。这时候就需要你修改这些文件来人肉合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记合并成功：<br><code>git add &lt;filename&gt;</code><br>在合并改动之前，也可以使用如下命令查看：<br><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p>
<h1 id="u6807_u7B7E"><a href="#u6807_u7B7E" class="headerlink" title="标签"></a>标签</h1><p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签：<br><code>git tag 1.0.0 1b2e1d63ff</code><br>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：<br><code>git log</code><br>你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。</p>
<h1 id="u66FF_u6362_u672C_u5730_u6539_u52A8"><a href="#u66FF_u6362_u672C_u5730_u6539_u52A8" class="headerlink" title="替换本地改动"></a>替换本地改动</h1><p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：<br><code>git checkout -- &lt;filename&gt;</code><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p>
<p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：<br><code>git fetch origin</code><br><code>git reset --hard origin/master</code></p>
<h1 id="u6709_u7528_u7684_u8D34_u58EB"><a href="#u6709_u7528_u7684_u8D34_u58EB" class="headerlink" title="有用的贴士"></a>有用的贴士</h1><p>内建的图形化 git：<br><code>gitk</code><br>彩色的 git 输出：<br><code>git config color.ui true</code><br>显示历史记录时，只显示一行注释信息：<br><code>git config format.pretty oneline</code><br>交互地添加文件至缓存区：<br><code>git add -i</code><br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/git_3.jpg" alt=""></p>
<h1 id="u94FE_u63A5_u4E0E_u8D44_u6E90"><a href="#u94FE_u63A5_u4E0E_u8D44_u6E90" class="headerlink" title="链接与资源"></a>链接与资源</h1><h2 id="u56FE_u5F62_u5316_u754C_u9762"><a href="#u56FE_u5F62_u5316_u754C_u9762" class="headerlink" title="图形化界面"></a>图形化界面</h2><p><code>GitX (L) (OSX, open source)``
</code>Tower (OSX)<code>`
</code>Source Tree (OSX, free)<code>`GitHub for Mac (OSX, free)</code><br><code>GitBox (OSX)</code></p>
<h2 id="u6307_u5357_u4E0E_u624B_u518C"><a href="#u6307_u5357_u4E0E_u624B_u518C" class="headerlink" title="指南与手册"></a>指南与手册</h2><p><a href="http://git-scm.com/book/en/v2" target="_blank" rel="external">Git 社区参考书</a><br><a href="http://git-scm.com/book/en/v2" target="_blank" rel="external">专业 Git</a><br><a href="http://think-like-a-git.net/" target="_blank" rel="external">如 git 思考</a><br><a href="https://help.github.com/" target="_blank" rel="external">GitHub 帮助</a><br><a href="http://marklodato.github.io/visual-git-guide/index-en.html" target="_blank" rel="external">图形化的 Git 指南一则</a></p>
<h1 id="u81EA_u8BA4_u4E3A_u6BD4_u8F83_u597D_u7684Git_u5B66_u4E60_u6559_u6750"><a href="#u81EA_u8BA4_u4E3A_u6BD4_u8F83_u597D_u7684Git_u5B66_u4E60_u6559_u6750" class="headerlink" title="自认为比较好的Git学习教材"></a>自认为比较好的Git学习教材</h1><ul>
<li><a href="https://www.atlassian.com/git/tutorials/" target="_blank" rel="external">https://www.atlassian.com/git/tutorials/</a></li>
<li><a href="http://git.oschina.net/progit/" target="_blank" rel="external">http://git.oschina.net/progit/</a></li>
<li><a href="http://www.cnblogs.com/whthomas/p/4564906.html" target="_blank" rel="external">http://www.cnblogs.com/whthomas/p/4564906.html</a></li>
<li><a href="http://www.imooc.com/article/1426" target="_blank" rel="external">http://www.imooc.com/article/1426</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[学会Git才发现自己是一个混迹互联网的coder]]>
    
    </summary>
    
      <category term="码农必备常识" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%A0%81%E5%86%9C%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
    
      <category term="Git" scheme="http://www.xuanzhangjiong.xyz/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android MVVM]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/07/20/Android-MVVM/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/07/20/Android-MVVM/</id>
    <published>2015-07-20T02:16:29.000Z</published>
    <updated>2015-12-30T09:24:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E00_u3001_u4EC0_u4E48_u662FMVVM"><a href="#u4E00_u3001_u4EC0_u4E48_u662FMVVM" class="headerlink" title="一、什么是MVVM"></a>一、什么是MVVM</h1><p>之前简单学习过MVVM，但是并没有付诸实践，在Android中使用这个设计模式，乘着<code>Data Binding Library</code>的发布，就来好好学习下MVVM。</p>
<p>首先从MVC开始吧，模型－视图－控制器。为了使得程序的各个部分分离降低耦合性，我们对代码的结构进行了划分。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvvm_1" alt=""></p>
<p>他们的通信方式也如上图所示，即View层触发操作通知到业务层完成逻辑处理，业务层完成业务逻辑之后通知Model层更新数据，数据更新完之后通知View层展现。在实际运用中人们发现View和Model之间的依赖还是太强，希望他们可以绝对独立的存在，慢慢的就演化出了MVP。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvvm_2" alt=""></p>
<p>Presenter替换掉了Controller，不仅仅处理逻辑部分。而且还控制着View的刷新，监听Model层的数据变化。这样隔离掉View和Model的关系后使得View层变的非常的薄，没有任何的逻辑部分又不用主动监听数据，被称之为“被动视图”。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvvm_3" alt=""></p>
<p>至于MVVM基本上和MVP一模一样，感觉只是名字替换了一下。他的关键技术就是今天的主题(Data Binding)。View的变化可以自动的反应在ViewModel上，ViewModel的数据变化也会自动反应到View上。这样开发者就不用处理接收事件和View更新的工作，框架已经帮你做好了。</p>
<h1 id="u4E8C_u3001Data_Bingding_Library"><a href="#u4E8C_u3001Data_Bingding_Library" class="headerlink" title="二、Data Bingding Library"></a>二、Data Bingding Library</h1><p>今年的Google IO 大会上，Android 团队发布了一个数据绑定框架（Data Binding Library）。以后可以直接在 layout 布局 xml 文件中绑定数据了，无需再 findViewById 然后手工设置数据了。其语法和使用方式和 JSP 中的 EL 表达式非常类似，从注解到data bingding。<br>下面就来介绍怎么使用Data Binding Library。</p>
<h2 id="u914D_u7F6E_u73AF_u5883"><a href="#u914D_u7F6E_u73AF_u5883" class="headerlink" title="配置环境"></a>配置环境</h2><p>目前，最新版的Android Studio已经内置了该框架的支持，配置起来也很简单，只需要编辑app目录下的build.gradle文件，添加下面的内容就好了</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">android</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        <span class="literal">enabled</span> = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Data_Binding_Layout_u6587_u4EF6"><a href="#Data_Binding_Layout_u6587_u4EF6" class="headerlink" title="Data Binding Layout文件"></a>Data Binding Layout文件</h2><p>Data Binding layout文件有点不同的是：起始根标签是 layout，接下来一个 data 元素以及一个 view 的根元素。这个 view 元素就是你没有使用Data Binding的layout文件的根元素。举例说明如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="tag">&lt;<span class="title">layout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">variable</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">type</span>=<span class="value">"com.example.User"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:text</span>=<span class="value">"@&#123;user.firstName&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:text</span>=<span class="value">"@&#123;user.lastName&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span><span class="tag">&lt;/<span class="title">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面定义了一个<code>com.example.User</code>类型的变量user，然后接着<code>android:text=&quot;@{user.firstName}&quot;</code>把变量user的firstName属性的值和TextView的text属性绑定起来。</p>
<h2 id="Data_Object"><a href="#Data_Object" class="headerlink" title="Data Object"></a>Data Object</h2><p>我们来看下上面用到的<code>com.example.User</code>对象。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class User &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> firstName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> lastName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User(<span class="keyword">String</span> firstName, <span class="keyword">String</span> lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他有两个public的属性firstName，lastName，这和上面layout文件里面的@{user.firstName}和@{user.lastName}对应<br>或者下面这种形式的对象也是支持的。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class User &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> firstName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> lastName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User(<span class="keyword">String</span> firstName, <span class="keyword">String</span> lastName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get<span class="label">XXX形式</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> getFirstName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者属性名和方法名相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> lastName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不觉得这和<code>Objective-c</code>的property很像嘛。</p>
<h2 id="u7ED1_u5B9A_u6570_u636E"><a href="#u7ED1_u5B9A_u6570_u636E" class="headerlink" title="绑定数据"></a>绑定数据</h2><p>添加完<data>标签后，Android Studio就会根据xml的文件名自动生成一个继承ViewDataBinding的类。例如: activity_main.xml就会生成ActivityMainBinding, 然后我们在Activity里面添加如下代码：</data></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    MainActivityBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.main_activity);</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"Test"</span>, <span class="string">"User"</span>);</span><br><span class="line">    binding.setUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7ED1_u5B9A_u4E8B_u4EF6"><a href="#u7ED1_u5B9A_u4E8B_u4EF6" class="headerlink" title="绑定事件"></a>绑定事件</h2><p>就像你可以在xml文件里面使用属性android:onClick绑定Activity里面的一个方法一样，Data Binding Library扩展了更多的事件可以用来绑定方法，比如View.OnLongClickListener有个方法onLongClick(), 你就可以使用android:onLongClick属性来绑定一个方法，需要注意的是绑定的方法的签名必须和该属性原本对应的方法的签名完全一样，否则编译阶段会报错。<br>下面举例来说明具体怎么使用，先看用来绑定事件的类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyHandlers</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickButton</span>(<span class="params">View view</span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFirstNameChanged</span>(<span class="params">Editable s</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是layout文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="tag">&lt;<span class="title">layout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">variable</span> <span class="attribute">name</span>=<span class="value">"handlers"</span> <span class="attribute">type</span>=<span class="value">"com.example.Handlers"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">variable</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">type</span>=<span class="value">"com.example.User"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">EditText</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:text</span>=<span class="value">"@&#123;user.firstName&#125;"</span></span><br><span class="line">            <span class="attribute">android:afterTextChanged</span>=<span class="value">"@&#123;handlers.afterFirstNameChanged&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">Button</span> <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:onClick</span>=<span class="value">"@&#123;handlers.onClickButton&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span><span class="tag">&lt;/<span class="title">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="u8868_u8FBE_u5F0F_u8BED_u8A00_uFF08Expression_Language_uFF09"><a href="#u8868_u8FBE_u5F0F_u8BED_u8A00_uFF08Expression_Language_uFF09" class="headerlink" title="表达式语言（Expression Language）"></a>表达式语言（Expression Language）</h3><p>你可以直接在layout文件里面使用常见的表达式：</p>
<ul>
<li>数学表达式 + – / * %</li>
<li>字符串链接 +</li>
<li>逻辑操作符 &amp;&amp; ||</li>
<li>二元操作符 &amp; | ^</li>
<li>一元操作符 + – ! ~</li>
<li>Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>
<li>比较 == &gt; &lt; &gt;= &lt;=</li>
<li>instanceof</li>
<li>Grouping ()</li>
<li>Literals – character, String, numeric, null</li>
<li>Cast</li>
<li>函数调用</li>
<li>值域引用（Field access）</li>
<li>通过[]访问数组里面的对象</li>
<li>三元操作符 ?:<br>示例：</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android:text=<span class="string">"<span class="subst">@&#123;String.valueOf(<span class="keyword">index</span> + <span class="number">1</span>)&#125;</span>"</span></span><br><span class="line">android:visibility=<span class="string">"<span class="subst">@&#123;age &amp;<span class="keyword">lt</span>; <span class="number">13</span> ? View.GONE : View.VISIBLE&#125;</span>"</span></span><br><span class="line">android:transitionName=<span class="string">'@&#123;"image_" + id&#125;'</span></span><br></pre></td></tr></table></figure>
<p>更多语法可以参考官网文档：<a href="http://developer.android.com/tools/data-binding/guide.html#expression_language" target="_blank" rel="external">http://developer.android.com/tools/data-binding/guide.html#expression_language</a></p>
<h2 id="u66F4_u65B0_u754C_u9762"><a href="#u66F4_u65B0_u754C_u9762" class="headerlink" title="更新界面"></a>更新界面</h2><p>有些时候，代码会修改我们绑定的对象的某些属性，那么怎么通知界面刷新呢？下面就给出两种方案。</p>
<h2 id="u65B9_u6848_u4E00"><a href="#u65B9_u6848_u4E00" class="headerlink" title="方案一"></a>方案一</h2><p>让你的绑定数据类继承BaseObservable，然后通过调用notifyPropertyChanged方法来通知界面属性改变，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseObservable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Bindable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    notifyPropertyChanged(BR.firstName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        notifyPropertyChanged(BR.lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要通知的属性的get方法上加上@Bindable，这样编译阶段会生成BR.[property name]，然后使用这个调用方法notifyPropertyChanged就可以通知界面刷新了。如果你的数据绑定类不能继承BaseObservable，那你就只能自己实现Observable接口，可以参考BaseObservable的实现。</p>
<h2 id="u65B9_u6848_u4E8C"><a href="#u65B9_u6848_u4E8C" class="headerlink" title="方案二"></a>方案二</h2><p>Data Binding Library提供了很便利的类ObservableField，还有ObservableBoolean, ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, 和 ObservableParcelable，基本上涵盖了各种我们需要的类型。用法很简单，如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; firstName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableField&lt;String&gt; lastName = <span class="keyword">new</span> ObservableField&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ObservableInt age = <span class="keyword">new</span> ObservableInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用下面的代码来访问：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.firstName.<span class="keyword">set</span>(<span class="string">"Google"</span>);</span><br><span class="line"><span class="keyword">int</span> age = user.age.<span class="keyword">get</span>();</span><br></pre></td></tr></table></figure></p>
<p>调用set方法时，Data Binding Library就会自动的帮我们通知界面刷新了。</p>
<h2 id="u7ED1_u5B9AAdapterView"><a href="#u7ED1_u5B9AAdapterView" class="headerlink" title="绑定AdapterView"></a>绑定AdapterView</h2><p>在一个实际的项目中，相信AdapterView是使用得很多的，使用官方提供给的API来进行AdapterView的绑定需要写很多代码，使用起来不方便，但是由于Data Binding Library提供丰富的扩展功能，所以出现了很多第三方的库来扩展它，下面就来介绍一个比较好用的库binding-collection-adapter，Github地址：<a href="https://github.com/evant/binding-collection-adapter" target="_blank" rel="external">https://github.com/evant/binding-collection-adapter</a><br>使用的时候在你的<code>build.gradle</code>文件里面添加<br><code>compile &#39;me.tatarka:bindingcollectionadapter:0.16&#39;</code><br>如果你要是用RecyclerView，还需要添加<br><code>compile &#39;me.tatarka:bindingcollectionadapter-recyclerview:0.16&#39;</code><br>下面就是ViewModel的写法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- layout.xml --&gt;</span><span class="tag">&lt;<span class="title">layout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">variable</span> <span class="attribute">name</span>=<span class="value">"viewModel"</span> <span class="attribute">type</span>=<span class="value">"com.example.ViewModel"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">import</span> <span class="attribute">type</span>=<span class="value">"me.tatarka.bindingcollectionadapter.LayoutManagers"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ListView</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">app:items</span>=<span class="value">"@&#123;viewModel.items&#125;"</span></span><br><span class="line">        <span class="attribute">app:itemView</span>=<span class="value">"@&#123;viewModel.itemView&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">android.support.v7.widget.RecyclerView</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">app:layoutManager</span>=<span class="value">"@&#123;LayoutManagers.linear()&#125;"</span></span><br><span class="line">        <span class="attribute">app:items</span>=<span class="value">"@&#123;viewModel.items&#125;"</span></span><br><span class="line">        <span class="attribute">app:itemView</span>=<span class="value">"@&#123;viewModel.itemView&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">android.support.v4.view.ViewPager</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">app:items</span>=<span class="value">"@&#123;viewModel.items&#125;"</span></span><br><span class="line">        <span class="attribute">app:itemView</span>=<span class="value">"@&#123;viewModel.itemView&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">Spinner</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">app:items</span>=<span class="value">"@&#123;viewModel.items&#125;"</span></span><br><span class="line">        <span class="attribute">app:itemView</span>=<span class="value">"@&#123;viewModel.itemView&#125;"</span></span><br><span class="line">        <span class="attribute">app:dropDownItemView</span>=<span class="value">"@&#123;viewModel.dropDownItemView&#125;"</span>/&gt;</span><span class="tag">&lt;/<span class="title">layout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后是item layout：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- item.xml --&gt;</span><span class="tag">&lt;<span class="title">layout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">variable</span> <span class="attribute">name</span>=<span class="value">"item"</span> <span class="attribute">type</span>=<span class="value">"String"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/text"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"@&#123;item&#125;"</span>/&gt;</span><span class="tag">&lt;/<span class="title">layout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果有多种样式的布局，那么就需要把ItemView换成ItemViewSelector， 如下：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ItemViewSelector&lt;String&gt; itemView = <span class="keyword">new</span> BaseItemViewSelector&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(ItemView itemView, <span class="keyword">int</span> position, String item)</span> </span>&#123;</span><br><span class="line">        itemView.set(BR.item, position == <span class="number">0</span> ? R.layout.item_header : R.layout.item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is only needed if you are using a BindingListViewAdapter</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">viewTypeCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="u81EA_u5B9A_u4E49_u7ED1_u5B9A"><a href="#u81EA_u5B9A_u4E49_u7ED1_u5B9A" class="headerlink" title="自定义绑定"></a>自定义绑定</h2><p>正常情况下，Data Binding Library会根据属性名去找对应的set方法，但是我们有时候需要自定义一些属性，Data Binding Library也提供了很便利的方法让我们来实现。<br>比如我们想在layout文件里面设置ListView的emptyView，以前这个是无法做到的，只能在代码里面通过调用setEmptyView来做；<br>但是现在借助Data Binding Library，我们可以很容易的实现这个功能了。先看layout文件：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="tag">&lt;<span class="title">layout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">variable</span></span><br><span class="line">            <span class="attribute">name</span>=<span class="value">"viewModel"</span></span><br><span class="line">            <span class="attribute">type</span>=<span class="value">"com.example.databinding.viewmodel.ViewAlbumsViewModel"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">LinearLayout</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:paddingLeft</span>=<span class="value">"10dp"</span></span><br><span class="line">        <span class="attribute">android:paddingRight</span>=<span class="value">"10dp"</span></span><br><span class="line">        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ListView</span></span><br><span class="line">            <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"0px"</span></span><br><span class="line">            <span class="attribute">android:layout_weight</span>=<span class="value">"1.0"</span></span><br><span class="line">            <span class="attribute">app:items</span>=<span class="value">"@</span></span></span><span class="expression">&#123;<span class="variable">viewModel.albums</span>&#125;</span><span class="xml"><span class="tag"><span class="value">"</span></span><br><span class="line">            <span class="attribute">app:itemView</span>=<span class="value">"@</span></span></span><span class="expression">&#123;<span class="variable">viewModel.itemView</span>&#125;</span><span class="xml"><span class="tag"><span class="value">"</span></span><br><span class="line">            <span class="attribute">app:emptyView</span>=<span class="value">"@</span></span></span><span class="expression">&#123;@<span class="variable">id</span><span class="end-block">/empty</span>_<span class="variable">view</span>&#125;</span><span class="xml"><span class="tag"><span class="value">"</span></span><br><span class="line">            <span class="attribute">android:onItemClick</span>=<span class="value">"@</span></span></span><span class="expression">&#123;<span class="variable">viewModel.viewAlbum</span>&#125;</span><span class="xml"><span class="tag"><span class="value">"</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/albumListView"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">            <span class="attribute">android:id</span>=<span class="value">"@+id/empty_view"</span></span><br><span class="line">            <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"0px"</span></span><br><span class="line">            <span class="attribute">android:layout_weight</span>=<span class="value">"1.0"</span></span><br><span class="line">            <span class="attribute">android:gravity</span>=<span class="value">"center"</span></span><br><span class="line">            <span class="attribute">android:text</span>=<span class="value">"@string/albums_list_empty"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">            <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">            <span class="attribute">android:text</span>=<span class="value">"@string/create"</span></span><br><span class="line">            <span class="attribute">android:onClick</span>=<span class="value">"@</span></span></span><span class="expression">&#123;<span class="variable">viewModel.createAlbum</span>&#125;</span><span class="xml"><span class="tag"><span class="value">"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span><span class="tag">&lt;/<span class="title">layout</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>app:emptyView=”@{@id/empty_view}”这个代码就用来指定emptyView，下面来看下实现的代码：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@BindingAdapter</span>(<span class="string">"emptyView"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">setEmptyView</span><span class="params">(AdapterView adapterView, <span class="keyword">int</span> viewId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    View rootView = adapterView.getRootView();</span><br><span class="line">    View emptyView = rootView.findViewById(viewId);</span><br><span class="line">    <span class="keyword">if</span> (emptyView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        adapterView.setEmptyView(emptyView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来分析上面的代码，<code>@{@id/empty_view}</code>表示引用了<code>@id/empty_view</code>这个id，所以它的值就是int，再看上面的setEmptyView方法，第一个参数<code>AdapterView adapterView</code>表示使用emptyView这个属性的控件，而第二个参数int viewId则是emptyView属性传进来的值，上面的layout可以看出来它就是<code>R.id.empty_view</code>，然后通过id找到控件，然后调用原始的setEmptyView来设置。</p>
<p>上面的代码来自<code>derron</code>写的一个Data Binding Library的示例项目DataBinding-album-sample，Github地址：<a href="https://github.com/derron/DataBinding-album-sample" target="_blank" rel="external">https://github.com/derron/DataBinding-album-sample</a></p>
]]></content>
    <summary type="html">
    <![CDATA[结合Android学习下MVVM]]>
    
    </summary>
    
      <category term="MVVM" scheme="http://www.xuanzhangjiong.xyz/tags/MVVM/"/>
    
      <category term="Android" scheme="http://www.xuanzhangjiong.xyz/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android常见问题总结]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/07/18/Android%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/07/18/Android常见问题总结/</id>
    <published>2015-07-18T06:29:05.000Z</published>
    <updated>2016-01-04T07:45:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E00_u3001_u5982_u679C_u540E_u53F0_u7684Activity_u7531_u4E8E_u67D0_u539F_u56E0_u88AB_u7CFB_u7EDF_u56DE_u6536_u4E86_uFF0C_u5982_u4F55_u5728_u88AB_u7CFB_u7EDF_u56DE_u6536_u4E4B_u524D_u4FDD_u5B58_u5F53_u524D_u72B6_u6001_uFF1F"><a href="#u4E00_u3001_u5982_u679C_u540E_u53F0_u7684Activity_u7531_u4E8E_u67D0_u539F_u56E0_u88AB_u7CFB_u7EDF_u56DE_u6536_u4E86_uFF0C_u5982_u4F55_u5728_u88AB_u7CFB_u7EDF_u56DE_u6536_u4E4B_u524D_u4FDD_u5B58_u5F53_u524D_u72B6_u6001_uFF1F" class="headerlink" title="一、如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？"></a>一、如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？</h1><p>在onSaveInstanceState()中保存其状态。activity被置于后台时，在执行onStop之前，通过onSaveInstacneState 保存当前activity状态。如果被系统杀死，再次被调起时，，在onResume之前，onStart之后，通过 onRestoreInstanceState（）来恢复其状态。如果没有被系统杀死，则不执行onRestoreInstanceState。 如果用户点击back键，则onSaveInstanceState()不会被调用。onSaveInstanceState()在以下几种情况会被调用： 1，按home键时；2，横竖屏切换时；3，按电源键时；4，从当前activity进入另一个activity时。 系统默认只会保存ui状态–view hierarchy，比如editext里面的text，或者listview的scroll位置， 不会保存别的信息，如果需要保存则复写此方法。</p>
<h1 id="u4E8C_u3001_u8BF7_u89E3_u91CA_u4E0B_u5728_u5355_u7EBF_u7A0B_u6A21_u578B_u4E2DMessage_u3001Handler_u3001Message_Queue_u3001Looper_u4E4B_u95F4_u7684_u5173_u7CFB_u3002"><a href="#u4E8C_u3001_u8BF7_u89E3_u91CA_u4E0B_u5728_u5355_u7EBF_u7A0B_u6A21_u578B_u4E2DMessage_u3001Handler_u3001Message_Queue_u3001Looper_u4E4B_u95F4_u7684_u5173_u7CFB_u3002" class="headerlink" title="二、请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。"></a>二、请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。</h1><p>Message：包含消息id，存放携带消息数据的消息对象，MessageQueue 统一管理，handler发送和处理； MessageQue 消息队列，管理message的队列，存放handler发过来的消息，链表串联， 经由looper抽取 Looper：消息泵，不断抽取messageQueue中的消息，一个messageque对应 一个looper。实现消息队列创建和消息循环功能。静态方法prepare和loop。 handler： 用来发送message和处理message。在使用handler之前必须使用looper创建了 队列，否则抛出异常。需要实现handleMessage来处理message。Thread 线程 负责调 度整个消息循环，即消息循环的执行场所。 有个问题，为什么非要出来个looper，而不是把looper的功能放到handler里面实现呢？ 我觉得是面向对象的原则，由于looper里面的功能基本不怎么变化，也不需要用户了解， 因此将其封装，仅仅将handler和message对用户开放去调用。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/handler-howtowork.png" alt=""></p>
<h1 id="u4E09_u3001TCP_u76843_u6B21_u63E1_u624B_u548C4_u6B21_u6325_u624B_uFF1F"><a href="#u4E09_u3001TCP_u76843_u6B21_u63E1_u624B_u548C4_u6B21_u6325_u624B_uFF1F" class="headerlink" title="三、TCP的3次握手和4次挥手？"></a>三、TCP的3次握手和4次挥手？</h1><p>3次握手连接，首先连接端发送一个连接请求，syn为1，接收端回复一个确认表示同意连接， 连接端发送确认，表示收到接收端的连接确认，至此连接成功，可以全双工的发送数据。</p>
<p>4次断开连接，首先连接端发送fin为1的请求，表示自己不再发送数据，接收端收到后发送 确认，并再次发送一个自己的fin请求，表示自己也不再发送数据，连接端发送确认，至此 断开连接成功。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/tcpconnect.png" alt=""></p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/tcpdisconnect.png" alt=""></p>
<h1 id="u56DB_u3001tcp_u4E09_u6B21_u63E1_u624B_u5B58_u5728_u7684_u98CE_u9669_uFF1F"><a href="#u56DB_u3001tcp_u4E09_u6B21_u63E1_u624B_u5B58_u5728_u7684_u98CE_u9669_uFF1F" class="headerlink" title="四、tcp三次握手存在的风险？"></a>四、tcp三次握手存在的风险？</h1><p>攻击方伪造IP地址发送大量的SYN包，使服务端发送的SYN+ACK包得不到确认，服务器端将 为了维护一个非常大的半连Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址， 向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的 ，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN 请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连 接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在Linux下可以如 下命令检测是否被Syn攻击 netstat -n -p TCP | grep SYN_RECV 一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方 法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等. 但是不能完全防范syn攻击。接列表而消耗非常多的资源，服务器失去响应，即服务器端受 到了SYN Flood攻击。</p>
<h1 id="u4E94_u3001_u4E3A_u4EC0_u4E48_u5173_u95ED_u8FDE_u63A5_u8981_u56DB_u6B21_u6325_u624B_uFF1F"><a href="#u4E94_u3001_u4E3A_u4EC0_u4E48_u5173_u95ED_u8FDE_u63A5_u8981_u56DB_u6B21_u6325_u624B_uFF1F" class="headerlink" title="五、为什么关闭连接要四次挥手？"></a>五、为什么关闭连接要四次挥手？</h1><p>TCP是全双工通道，一方发起关闭请求只关闭了一个方向上的通道，所以建立连接的双方都 要发起关闭请求并确认来关闭各自方向上的数据通道。</p>
<h1 id="u516D_u3001_u4E3A_u4EC0_u4E48_u5EFA_u7ACB_u8FDE_u63A5_u8981_u4E09_u6B21_u63E1_u624B_uFF1F"><a href="#u516D_u3001_u4E3A_u4EC0_u4E48_u5EFA_u7ACB_u8FDE_u63A5_u8981_u4E09_u6B21_u63E1_u624B_uFF1F" class="headerlink" title="六、为什么建立连接要三次握手？"></a>六、为什么建立连接要三次握手？</h1><p>目的： 防止已经失效的连接请求到达服务端，创建无效的连接，浪费资源。 说明： 当客户端发出的第一个连接请求在网络上的某个节点被滞留了（网络会存在许多不 可靠的因素），过一段时间后突然又到达了服务端，服务端误以为这是一个新的建立连接 的请求，于是就会向客户端发出确认包并建立连接。 实际上客户端当前并没有发出创建连接的请求，就会丢弃服务端的确认包。而服务端却创 建了连接并等待客户端发送数据，浪费了相关的资源。</p>
<h1 id="u4E03_u3001tcp_u62E5_u585E_u63A7_u5236_u673A_u5236_uFF1F"><a href="#u4E03_u3001tcp_u62E5_u585E_u63A7_u5236_u673A_u5236_uFF1F" class="headerlink" title="七、tcp拥塞控制机制？"></a>七、tcp拥塞控制机制？</h1><p>计算机网络中的带宽、交换节点中缓存和处理机等，都是网络资源。在某段时间，若对网络 中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫 做阻塞。拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致 过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。 (1) 拥塞窗口（cwnd）:拥塞控制的关键参数，它描述源端在拥塞控制情况下一次最多能发送 的数据包的数量。 (2) 通告窗口（awin）:接收端给源端预设的发送窗口大小，它只在TCP连接建立的初始阶段 发挥作用。 (3) 发送窗口（win）:源端每次实际发送数据的窗口大小。 (4) 慢启动阈值（ssthresh）:拥塞控制中慢启动阶段和拥塞避免阶段的分界点。初始值通 常设为65535byte。 (5) 回路响应时间（RTT）:一个TCP数据包从源端发送到接收端，源端收到接收端确认的时间 间隔。 (6) 超时重传计数器（RTO）:描述数据包从发送到失效的时间间隔，是判断数据包丢失与否 及网络是否拥塞的重要参数。通常设为2RTT或5RTT。 (7) 快速重传阈值(tcprexmtthresh):：能触发快速重传的源端收到重复确认包ACK的个数。 当此个数超过tcprexmtthresh时，网络就进入快速重传阶段。tcprexmtthresh缺省值为3。</p>
<h2 id="1__u6162_u5F00_u59CB_u4E0E_u62E5_u585E_u907F_u514D"><a href="#1__u6162_u5F00_u59CB_u4E0E_u62E5_u585E_u907F_u514D" class="headerlink" title="1 慢开始与拥塞避免"></a>1 慢开始与拥塞避免</h2><p>发送方维持一个叫做拥塞窗口cwnd(congestion window)的状态变量。拥塞窗口的大小取决 于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口个，另外 考虑到接收方的接受能力，发送窗口可能小于拥塞窗口。 慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度， 就是由小到大的逐渐增加拥塞窗口的大小。如图所示</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/tcp%E6%85%A2%E5%BC%80%E5%A7%8B.png" alt=""></p>
<p>当建立连接后，设置cwnd为1（这里用报文段的个数的拥塞窗口大小举例说明慢开始算法 ，实时拥塞窗口大小是以字节为单位的），发送1个数据包，接收方接收到后，发送确认 信息；cwnd变为1×2，发送2个数据包，接收方接收到后，发送2个确认信息；cwnd变为2×2 ，发送4个数据包，接收方收到后，发送4个确认信息，cwnd变为4×2… 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。 ssthresh的用法如下： 当cwndssthresh时，改用拥塞避免算法。 当cwnd=ssthresh时，慢开始与拥塞避免算法任意。 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口 cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是 没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所 以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然 后把拥塞窗口设置为1，执行慢开始算法。</p>
<h2 id="2__u5FEB_u91CD_u4F20_u548C_u5FEB_u6062_u590D"><a href="#2__u5FEB_u91CD_u4F20_u548C_u5FEB_u6062_u590D" class="headerlink" title="2 快重传和快恢复"></a>2 快重传和快恢复</h2><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发 送数据是捎带确认。快重传算法规定，发送发只要一连收到3个重复确认就应当立即重传 对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 快重传配合使用的还有快恢复算法，有以下两个要点: ①当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但 是接下去并不执行慢开始算法。 ②考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络 可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然 后执行拥塞避免算法。如</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/tcp%E5%BF%AB%E9%87%8D%E4%BC%A0.png" alt=""></p>
<h1 id="u516B_u3001Android_ipc_u7684_u65B9_u5F0Faidl_u7684_u673A_u5236_uFF1F_u4E0E_u4F20_u7EDF_u7684linux_ipc_u533A_u522B_uFF1F"><a href="#u516B_u3001Android_ipc_u7684_u65B9_u5F0Faidl_u7684_u673A_u5236_uFF1F_u4E0E_u4F20_u7EDF_u7684linux_ipc_u533A_u522B_uFF1F" class="headerlink" title="八、Android ipc的方式aidl的机制？与传统的linux ipc区别？"></a>八、Android ipc的方式aidl的机制？与传统的linux ipc区别？</h1><p>先说区别，aidl是解决android进程通信问题，是一种rpc的调用方式。由Dianne Hackbor提出。传统的linux通信有pipe管道、信号和跟踪。但其都局限于父进程与子进程之间，或者兄弟进程之间，后来增加了命名管道，使得不再局限于亲戚之间进程，后来AT&amp;T Unix又增加报文队列，共享内存和信号量，BSD Linux增加了socket进程通信机制。为什么android自己设计一个新的ipc方式，原因如下： 另一方面是传输性能。socket作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。 各种IPC方式数据拷贝次数如下表：</p>
<p>IPC 数据copy次数 共内存 0 Binder 1 Socket/Pipe/消息队列 2</p>
<p>还有一点是出于安全性考虑。Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。首先传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</p>
<p>Binder提供了远程过程调用RPC功能，英文意思是粘结剂的意思。在android的binder机制中，由一系列组件组成，分别是client，server，service manager和binder驱动程序，其中client，server和service manager运行在用户空间，binder驱动程序运行在内核空间，binder就是将这四个组件粘合在一起的粘结剂，其中核心组件便是binder驱动程序，service manger提供了辅助管理功能，client和server正式在binder驱动和service manger提供的基础设施上，进行client-server之间的通信。Service Manager和Binder驱动已经在Android平台中实现好，开发者只要按照规范实现自己的Client和Server组件就可以了。如图所示</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/aidl_structure.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u4E00_u3001_u5982_u679C_u540E_u53F0_u7684Activity_u7531_u4E8E_u67D0_u539F_u56E0_u88AB_u7CFB_u7EDF_u56DE_u6536_u4E86_uFF0C_u5982_u4F5]]>
    </summary>
    
      <category term="常见问题总结" scheme="http://www.xuanzhangjiong.xyz/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="Android" scheme="http://www.xuanzhangjiong.xyz/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MVC、MVP、MVVM的个人理解]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/07/15/MVC%E3%80%81MVP%E3%80%81MVVM%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/07/15/MVC、MVP、MVVM的个人理解/</id>
    <published>2015-07-15T12:32:08.000Z</published>
    <updated>2015-12-19T13:05:54.000Z</updated>
    <content type="html"><![CDATA[<p>从最初的只要把功能实现出来可以不择手段，到代码太乱了，整理整理吧，再到看看别人写的代码，那就把每个类分分类吧。嗯，再看看那些开源的项目，自己不得不开始思考系统架构了，因为，它就好比代码中的书法，然而它比书法更重要，因为，有一个好的架构不仅可以使得项目更加便于阅读，理解，甚至在有些时候执行效率也更好，so…..</p>
<p>MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。</p>
<h1 id="u4E00_u3001MVC"><a href="#u4E00_u3001MVC" class="headerlink" title="一、MVC"></a>一、MVC</h1><p>MVC模式的意思是，软件可以分成三个部分。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_1.png" alt=""></p>
<ul>
<li>视图（View）：用户界面。</li>
<li>控制器（Controller）：业务逻辑</li>
<li>模型（Model）：数据保存<br><br></li>
</ul>
<hr>
<p>各部分之间的通信方式如下。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_2.png" alt=""></p>
<ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ol>
<p>所有通信都是单向的。</p>
<h1 id="u4E8C_u3001_u4E92_u52A8_u6A21_u5F0F"><a href="#u4E8C_u3001_u4E92_u52A8_u6A21_u5F0F" class="headerlink" title="二、互动模式"></a>二、互动模式</h1><p>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_3.png" alt=""></p>
<p>另一种是直接通过controller接受指令。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_4.png" alt=""></p>
<h1 id="u4E09_u3001_u5B9E_u4F8B_uFF1ABackbone"><a href="#u4E09_u3001_u5B9E_u4F8B_uFF1ABackbone" class="headerlink" title="三、实例：Backbone"></a>三、实例：Backbone</h1><p>但是实际项目往往采取更加灵活的方式，以 Backbone.js 为例。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_5.png" alt=""></p>
<ol>
<li>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</li>
<li>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</li>
<li>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</li>
</ol>
<h1 id="u56DB_u3001MVP"><a href="#u56DB_u3001MVP" class="headerlink" title="四、MVP"></a>四、MVP</h1><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvp.png" alt=""></p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ol>
<h1 id="u4E94_u3001MVVM"><a href="#u4E94_u3001MVVM" class="headerlink" title="五、MVVM"></a>五、MVVM</h1><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvvm.png" alt=""></p>
<p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p>
]]></content>
    <summary type="html">
    <![CDATA[对3种系统架构的浅显理解]]>
    
    </summary>
    
      <category term="常见3种架构" scheme="http://www.xuanzhangjiong.xyz/tags/%E5%B8%B8%E8%A7%813%E7%A7%8D%E6%9E%B6%E6%9E%84/"/>
    
      <category term="架构" scheme="http://www.xuanzhangjiong.xyz/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开篇]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/06/20/%E5%BC%80%E7%AF%87/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/06/20/开篇/</id>
    <published>2015-06-20T11:50:11.000Z</published>
    <updated>2015-12-07T08:56:27.000Z</updated>
    <content type="html"><![CDATA[<p>今天很开心，因为毕业了～！！！可以有时间好好学习自己想学的东西，专心做一个coder。</p>
<h1 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h1><p>前一段时间，了解了一些搭建个人博客的方法，比较起来，hexo在我眼里秒杀一切，或许是由于我对<a href="http://www.nodejs.org" target="_blank" rel="external">node</a>中毒太深吧。</p>
<p>在阿里云上买了一个域名＋<a href="https://pages.github.com" target="_blank" rel="external">GitHub Pages</a>＋<a href="https://hexo.io" target="_blank" rel="external">Hexo</a>,以成本价4RMB的价格搭建了我的<a href="http://www.xuanzhangjiong.xyz">blog</a>。<br>大家如果也希望搭建自己的blog的话，看几篇教程，没有发现特别完整的，我也是看了n篇，然后把<a href="https://hexo.io" target="_blank" rel="external">https://hexo.io</a>上的DOCS看完，选一个自己心仪的主题，定制成自己喜欢的风格，然后就可以开始自己的blog之路了。<br>对了如果你的blog中图片太多的话，建议你用七牛云存储，不是帮他们打广告哈，只是没有CDN加速，访问效率可能真的真的…<br>这是我的邀请链接：<a href="https://portal.qiniu.com/signup?code=3ll21mpkdin2q" target="_blank" rel="external">https://portal.qiniu.com/signup?code=3ll21mpkdin2q</a>，好人一生平安，嘻嘻。</p>
<h1 id="u5B9A_u4F4D"><a href="#u5B9A_u4F4D" class="headerlink" title="定位"></a>定位</h1><p>我喜欢移动开发，擅长Android开发，但也不乏对iOS、Javascript全栈有着浓厚的兴趣，虽然现在只是个菜，但是希望以后能成为一颗大白菜。也许有人会说以后以后只会从事一个方向的工作，何必学着么多呢，我也曾想过，坚持下去的理由却很简单：喜欢就好，何必在乎这么多呢。所以以后我的blog的定位也是：</p>
<blockquote>
<p>Android<br>iOS<br>Web前端<br>Git<br>Node.js</p>
</blockquote>
<p>边学习边分享吧，大家共同进步。</p>
<h1 id="u521D_u8877"><a href="#u521D_u8877" class="headerlink" title="初衷"></a>初衷</h1><p>写博客只为记录自己的开发历程，希望自己在这个互联网时代中留下一些自己的足迹，证明自己也曾为开源做过贡献。</p>
]]></content>
    <summary type="html">
    <![CDATA[磨蹭了几个月的blog终于开篇了]]>
    
    </summary>
    
      <category term="毕业季" scheme="http://www.xuanzhangjiong.xyz/tags/%E6%AF%95%E4%B8%9A%E5%AD%A3/"/>
    
      <category term="生活小记" scheme="http://www.xuanzhangjiong.xyz/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
