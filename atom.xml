<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[TopJohn'Blog]]></title>
  <subtitle><![CDATA[Coding的路上，至少我乐在其中...]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.xuanzhangjiong.xyz/"/>
  <updated>2015-12-20T08:13:28.000Z</updated>
  <id>http://www.xuanzhangjiong.xyz/</id>
  
  <author>
    <name><![CDATA[John]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[参加腾讯Innovation Space比赛的感想]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/12/20/%E5%8F%82%E5%8A%A0%E8%85%BE%E8%AE%AFInnovation-Space%E6%AF%94%E8%B5%9B%E7%9A%84%E6%84%9F%E6%83%B3/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/12/20/参加腾讯Innovation-Space比赛的感想/</id>
    <published>2015-12-20T05:45:52.000Z</published>
    <updated>2015-12-20T08:13:28.000Z</updated>
    <content type="html"><![CDATA[<p>2015年11月26日，我和几个小伙伴带着创意在线报名了腾讯的Innovation Space 比赛，几经筛选，我们从270多个创意中，进入了总决赛。</p>
<p>12月11日，我们背上行囊奔赴上海腾讯，当然这也是第一次去腾讯，内心很激动。</p>
<p>12月11日傍晚，腾讯的HR姐姐，带我们参观了上海腾讯的腾云大厦，以及比赛团队的介绍。</p>
<p>12月12日上午，经历了半天的商业模式的洗礼。到了下午我们开始了58小时的封闭式开发。哦，忘了介绍我们的团队了：一名腾讯的产品姐姐，一名腾讯的前端大牛，一名上大的研究生学长（后端开发），以及3名浙大的骚年，一名iOS开发，一名设计，还有做Android的我。</p>
<p>我们做的产品是<code>刷脸加好友</code>,在那58小时里，我们配合的很默契，其中也出现了很多的问题：特别吐槽下腾讯的GuestWifi,慢的和乌龟一样，而且莫名地不定时地局域网无法ping通，在调试接口的时候，我们几经崩溃。最后迫于无奈，用的手机热点来，调试，是不是醉了，哈哈。</p>
<p>58小时里，我们几乎都没怎么睡觉，一直在14号中午快开始路演的时候还在调试，心好累。。。。</p>
<p>刷脸加好友的创意首先是来自于我们发现了腾讯的优图接口，我们想利用优图实现传统加好友的局限性，能够仅仅通过一张老照片，对仅仅只有一面之缘的又无法联系到的人通过社交平台添加好友，这是我们的初衷。</p>
<p>说了半天，获奖没，并没有，当路演完，评审完，我们意识到了，哦，原来商业模式也是很重要的，不仅创意要好，产品要做出来，而且要能够让投资人能够了解到创意背后的商业价值，好吧，也许我们在这方面思考欠佳。</p>
<p>但是这并不影响我对这次比赛的感受，还是很值得的，体验了58小时的封闭式开发，感受了BAT之一的大公司，了解了一个公司，认识了这么多小伙伴。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/innovation_space.png" alt="附上一张合照" title="合照"></p>
<p>项目的客户端代码已经放到我的Github上了，需要的小伙伴可以自己下载，做的比较简陋，毕竟只有58小时，希望不要见怪。</p>
<p>当然无图无真相：<br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_5.jpg?imageView2/2/w/360/h/640" alt="">    <img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_4.jpg?imageView2/2/w/360/h/640" alt=""><br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_3.jpg?imageView2/2/w/360/h/640" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_6.jpg?imageView2/2/w/360/h/640" alt=""><br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_2.jpg?imageView2/2/w/360/h/640" alt=""> <img src="http://7xoz2q.com1.z0.glb.clouddn.com/faceswiping_1.jpg?imageView2/2/w/360/h/640" alt=""><br><br></p>
<p>Git地址：<a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x67;&#105;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;&#x3a;&#x54;&#111;&#112;&#x4a;&#111;&#x68;&#110;&#47;&#102;&#x61;&#x63;&#x65;&#83;&#119;&#105;&#x70;&#x69;&#x6e;&#x67;&#46;&#103;&#x69;&#116;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;&#x3a;&#x54;&#111;&#112;&#x4a;&#111;&#x68;&#110;&#47;&#102;&#x61;&#x63;&#x65;&#83;&#119;&#105;&#x70;&#x69;&#x6e;&#x67;&#46;&#103;&#x69;&#116;</a></p>
]]></content>
    <summary type="html">
    <![CDATA[虽然并没有获奖，但是认识了一群小伙伴，经历了，很值得...]]>
    
    </summary>
    
      <category term="生活感言" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E8%A8%80/"/>
    
      <category term="项目经历" scheme="http://www.xuanzhangjiong.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
      <category term="作品" scheme="http://www.xuanzhangjiong.xyz/categories/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/%E4%BD%9C%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android技术贴总汇]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/12/19/android%E5%AD%A6%E4%B9%A0%E6%80%BB%E6%B1%87/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/12/19/android学习总汇/</id>
    <published>2015-12-19T08:12:38.000Z</published>
    <updated>2015-12-19T11:53:04.000Z</updated>
    <content type="html"><![CDATA[<p>收藏夹里积攒了好多自己喜欢的blog和帖子，是时候找个时间整理下了，方便他人学习，为他人填坑，也方便自己以后的回顾，so,let’s begin…</p>
<ul>
<li><p><a href="http://www.stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路</a>从android开发入门，到后来的进阶，stormzhang提供了许多自己宝贵的经验，值得拜读。</p>
</li>
<li><p><a href="http://tech.meituan.com/" target="_blank" rel="external">美团技术团队</a>美团在做一些技术上的分享，在国内属于领先的地位，里面有一些和移动开发相关高质量文章。</p>
</li>
<li><p><a href="http://bugly.qq.com/blog/" target="_blank" rel="external">腾讯Bugly博客</a>腾讯Bugly博客</p>
</li>
<li><p><a href="http://tools.android.com/recent" target="_blank" rel="external">Recent Changes</a>了解Android新动态，需要翻墙。</p>
</li>
<li><p><a href="http://androidweekly.net/" target="_blank" rel="external">Android Weekly</a>Android周报，英文，邮箱订阅。</p>
</li>
<li><p><a href="http://www.androidweekly.cn/" target="_blank" rel="external">Android 开发技术周报</a>国内的开发周报。</p>
</li>
<li><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="external">AndroidDevTools</a>提供了不翻墙下载Android相关工具的服务。</p>
</li>
<li><p><a href="http://android-developers.blogspot.ca/" target="_blank" rel="external">Android Blog</a>Android 官方的开发博客。</p>
</li>
<li><p><a href="http://developer.android.com/intl/zh-cn/index.html" target="_blank" rel="external">Android官网</a>官网对开发者提供了许多教程以及开发实例，坚持阅读，相信会受益匪浅。毋庸置疑，官网需要翻墙。</p>
</li>
<li><p><a href="https://github.com/pcqpcq/open-source-android-apps" target="_blank" rel="external">Android开源项目</a>提供了众多不同领域的开源项目，值得学习。</p>
</li>
<li><p><a href="http://www.jianshu.com/p/1078568e859f" target="_blank" rel="external">Android Material Design 最佳实践项目</a>对于Material Design众多组件的使用给出了详细的讲解说明，是MD入门的利器。</p>
</li>
<li><p><a href="http://v.youku.com/v_show/id_XODk2NjkwNjM2.html?f=23494296&amp;from=y1.7-1.3" target="_blank" rel="external">Android 性能模式 第一季(中字幕)</a>Google官方推出的性能优化视频，第一季。最初发布在Youtube，Google为了方便天朝人民观看，在优酷上也放了一份。</p>
</li>
<li><p><a href="http://v.youku.com/v_show/id_XMTMxNDIzODcxMg==.html?f=26016201&amp;from=y1.7-3" target="_blank" rel="external">Android 性能模式 第二季(中字幕)</a>Google官方推出的性能优化视频，第二季。</p>
</li>
<li><p><a href="http://v.youku.com/v_show/id_XMTMwMTYzNDQwMA==.html?f=25972284&amp;from=y1.7-3" target="_blank" rel="external">Android 性能模式 第三季(英字幕)</a>Google官方推出的性能优化视频，第三季。</p>
</li>
<li><p><a href="http://v.youku.com/v_show/id_XMTM1OTI3NDE2NA==.html?f=26144822&amp;from=y1.7-3" target="_blank" rel="external">Android 性能模式 第四季(英字幕)</a>Google官方推出的性能优化视频，第四季。</p>
</li>
<li><p><a href="http://hukai.me/" target="_blank" rel="external">胡凯的博客</a>胡凯大神，腾讯Android高级开发，做了许多优质的分享，发起了翻译Android Training Course的活动。</p>
</li>
<li><p><a href="http://a.codekk.com/" target="_blank" rel="external">CodeKK</a>国内Android开源领袖级的人物，博客中有许多眼前一亮的干货。</p>
</li>
<li><p><a href="http://litesuits.com/" target="_blank" rel="external">Lite Your Android</a>博主倡导极简生活，开源了一些极简概念的Android库。</p>
</li>
<li><p><a href="http://www.vmatianyu.cn/" target="_blank" rel="external">Liter’s Blog</a>这是上一条推荐项目的博主的个人博客，前辈的博文语重心长，非常诚恳。</p>
</li>
<li><p><a href="http://keeganlee.me/" target="_blank" rel="external">Keegan小钢</a>博客中又对Android动画以及项目重构的实战讲解。</p>
</li>
<li><p><a href="http://it.deepinmind.com/index.html" target="_blank" rel="external">Java基础及深入</a>非常棒的一个博客，有关Java学习的博文质量很高。</p>
</li>
<li><p><a href="http://www.itechzero.com/google-mirror-sites-collect.html" target="_blank" rel="external">Google镜像集合</a>持续更新，让你不翻墙也可以用Google搜索。</p>
</li>
<li><p><a href="http://blog.knownsec.com/Knownsec_RD_Checklist/v3.0.html" target="_blank" rel="external">知道创宇研发技能表v3.0</a>对于Programer或者Geeker来说，这个技能表是必备的。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[平时发现的优质blog和技术贴，会持续更新]]>
    
    </summary>
    
      <category term="Android进阶优质资源" scheme="http://www.xuanzhangjiong.xyz/tags/Android%E8%BF%9B%E9%98%B6%E4%BC%98%E8%B4%A8%E8%B5%84%E6%BA%90/"/>
    
      <category term="Android" scheme="http://www.xuanzhangjiong.xyz/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[柚子房东，第一个从无到有的创业项目]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/12/01/%E6%9F%9A%E5%AD%90%E6%88%BF%E4%B8%9C%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BB%8E%E6%97%A0%E5%88%B0%E6%9C%89%E7%9A%84%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/12/01/柚子房东，第一个从无到有的创业项目/</id>
    <published>2015-12-01T06:52:05.000Z</published>
    <updated>2015-12-20T08:52:02.000Z</updated>
    <content type="html"><![CDATA[<p>七月中旬，在和导师的一番交流后，我加入了<code>柚子房东</code>这个项目，其实当时还不叫这个名字，叫<code>V-house</code>，来到了苏州金鸡湖边的一个酒店和一群从事房地产的人开始了我们的创业之路。</p>
<p>记得当时，大学还刚毕业不久，便开始了长达一个多月的酒店式封闭开发。</p>
<p>7月中旬，当时产品还没有确定最终的方向，大佬们还在讨论公司走向，作为码农，我只好先开始了各种填坑工作，对各种技术进行调研。一开始，我们曾经想过用<a href="http://ionicframework.com/" target="_blank" rel="external">Ionic</a>来开发，毕竟Hybrid的开发速度比原生的会快很多。在试过水之后，发现在没有遇到重大技术障碍的时候，Hybrid的应用确实可以迅速开发出来。但是遇到在用刀第三方服务的时候就会发现虽然有些第三方服务是支持<code>Codova</code>，但是遇到那些不支持的时候，开发显然会遇到问题，当然并不是说不可行，可以用Js去调用原生的API。在体验过一些用Ionic开发的项目之后发现，用户体验太！差！了！于是乎，果断放弃了这个坑，当然，那个时候还没有出现React Native不然，我可能会…</p>
<p>言归正传，当时由于之前一直使用Eclipse进行开发，但是Eclipse的效率真的不敢恭维，Android Studio也比较成熟了，所以打算从这个项目入手，我的Android Studio填坑之路也开始了。</p>
<h1 id="一、前期的技术调研">一、前期的技术调研</h1>]]></content>
    <summary type="html">
    <![CDATA[柚子房东这个项目，从7月中旬开始定需求，设计，开发，也经历了4个多月了，v1.0也算是上线了，来谈谈这几个月的感想吧。]]>
    
    </summary>
    
      <category term="创业项目，一个字“累”" scheme="http://www.xuanzhangjiong.xyz/tags/%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E2%80%9C%E7%B4%AF%E2%80%9D/"/>
    
      <category term="作品" scheme="http://www.xuanzhangjiong.xyz/categories/%E4%BD%9C%E5%93%81/"/>
    
      <category term="项目经历" scheme="http://www.xuanzhangjiong.xyz/categories/%E4%BD%9C%E5%93%81/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MarkDown语法练习]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/10/10/MarkDown%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/10/10/MarkDown语法练习/</id>
    <published>2015-10-10T08:51:41.000Z</published>
    <updated>2015-12-20T10:45:33.000Z</updated>
    <content type="html"><![CDATA[<p>写一些最简单，最实用的，下面的都是我用来写博客的。</p>
<h1 id="强调">强调</h1><p>星号*与下划线_都可以，单是斜体，双是粗体，符号可跨行，符号可加空格</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span>单星号是斜体<span class="keyword">*</span></span><br></pre></td></tr></table></figure>
<p><em>单星号是斜体</em></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span>双星号是粗体<span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure>
<p><strong>双星号是粗体</strong></p>
<h1 id="分割线">分割线</h1><p>三个或更多_*，必须单独一行，可含空格</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="引用">引用</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">翻译成html就是<span class="tag">&lt;<span class="title">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="title">blockquote</span>&gt;</span>，符号&gt;后的空格可不要</span><br><span class="line">&gt;引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用</p>
</blockquote>
<p>注意使用空行结束</p>
<p>内层符号前的空格必须要</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br><span class="line"> <span class="prompt">&gt;&gt;</span>引用中的引用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用</p>
<blockquote>
<p>引用中的引用</p>
</blockquote>
</blockquote>
<h1 id="标题">标题</h1><p>Setext方式<br>三个=-或更多</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">大标题</span><br><span class="line">===</span></span><br></pre></td></tr></table></figure>
<h1 id="大标题">大标题</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">小标题</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure>
<h2 id="小标题">小标题</h2><p>标题Atx方式<br>符号#必须加空格</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 一级标题</span></span><br><span class="line"><span class="preprocessor">## 二级标题</span></span><br><span class="line"><span class="preprocessor">### 三级标题</span></span><br><span class="line"><span class="preprocessor">#### 四级标题</span></span><br><span class="line"><span class="preprocessor">##### 五级标题</span></span><br><span class="line"><span class="preprocessor">###### 六级标题</span></span><br></pre></td></tr></table></figure>
<h1 id="无序列表">无序列表</h1><p>符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！</span><br></pre></td></tr></table></figure>
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！</li>
</ul>
<h1 id="有序列表">有序列表</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 有序列表</span><br><span class="line"><span class="number">2.</span> 有序列表</span><br><span class="line"><span class="number">3.</span> 有序列表</span><br><span class="line"><span class="number">4.</span> 有序列表</span><br></pre></td></tr></table></figure>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<h1 id="嵌套列表">嵌套列表</h1><p>+*-可循环使用，但符号之后的空格不能少，次级列表中符号之前的空格也不能少</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> 嵌套列表</span><br><span class="line"></span> + 嵌套列表</span><br><span class="line"> + 嵌套列表</span><br><span class="line">  -<span class="ruby"> 嵌套列表</span><br><span class="line"></span>   * 嵌套列表</span><br><span class="line">-<span class="ruby"> 嵌套列表</span></span><br></pre></td></tr></table></figure>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
<li>嵌套列表</li>
</ul>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
</ul>
</li>
</ul>
</li>
<li>嵌套列表</li>
</ul>
<h1 id="文字超链：Inline方式">文字超链：Inline方式</h1><p>Tooltips可省略</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[]</span><span class="list">(<span class="keyword">http://blog.xuanzhangjiong.xyz</span>)</span></span><br></pre></td></tr></table></figure>
<p><a href="http://blog.xuanzhangjiong.xyz" target="_blank" rel="external"></a></p>
<h1 id="图片超链">图片超链</h1><p>多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="link_label">GitHub Mark</span>](<span class="link_url">http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png "GitHub Mark"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Mark" title="GitHub Mark"></p>
<h1 id="索引超链：Reference方式">索引超链：Reference方式</h1><p>索引，1 2可以是任意字符</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="link_label">Stepway's Notes</span>][<span class="link_reference">1</span>]</span><br><span class="line">![<span class="link_label">GitHub Octocat</span>][<span class="link_reference">2</span>]</span><br><span class="line">[<span class="link_reference">1</span>]:<span class="link_url">http://blog.xuanzhangjiong.xyz</span></span><br><span class="line">[<span class="link_reference">2</span>]:<span class="link_url">http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png</span></span><br></pre></td></tr></table></figure>
<p><a href="http://blog.xuanzhangjiong.xyz" target="_blank" rel="external">TopJohn’s Blog</a><br><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png" alt="GitHub Octocat"></p>
<h1 id="自动链接">自动链接</h1><p>尖括号</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">http:</span><span class="comment">//blog.xuanzhangjiong.xyz&gt;</span></span><br><span class="line">&lt;<span class="string">http:</span><span class="comment">//TopJohn.github.io&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="代码">代码</h1><p>行内代码 使用符号`</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">`v</span>al s = <span class="string">"hello Markdown"</span><span class="escape">`</span><br><span class="line"></span><span class="escape">``</span>val s = <span class="string">"hello Markdown"</span> 需要显示(<span class="escape">`)</span><span class="escape">``</span></span><br></pre></td></tr></table></figure>
<p><code>val s = &quot;hello Markdown&quot;</code><br><code>val s = &quot;hello Markdown&quot; 需要显示(`)</code></p>
<h1 id="段落代码">段落代码</h1><p>每行文字前加4个空格或者1个Tab，并用空行开始</p>
<p>这是一个普通段落：<br>    这是一个代码区块。<br>    这是一个代码区块。</p>
<h1 id="hexo代码">hexo代码</h1><p>可指定编程语言，{ % % }代表左右大括号</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:php] [url] [link text]%&#125;</span><br><span class="line">  <span class="variable">$word</span> = <span class="string">'hello'</span></span><br><span class="line">  echo <span class="variable">$word</span>;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><figcaption><span>php</span><a href="http://blog.xuanzhangjiong.xyz" target="_blank" rel="external">link php</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$word</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$word</span>;</span><br></pre></td></tr></table></figure>
<h1 id="注释">注释</h1><p>用html的注释<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对当前编辑文件(.md)的注释 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="转义字符">转义字符</h1><p>Markdown中的转义字符为\，转义的有：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="command">\\</span> 反斜杠</span><br><span class="line"><span class="command">\`</span> 反引号</span><br><span class="line"><span class="command">\*</span> 星号</span><br><span class="line"><span class="command">\_</span> 下划线</span><br><span class="line"><span class="command">\&#123;</span><span class="command">\&#125;</span> 大括号</span><br><span class="line"><span class="command">\[</span><span class="command">\]</span> 中括号</span><br><span class="line"><span class="command">\(</span><span class="command">\)</span> 小括号</span><br><span class="line"><span class="command">\#</span> 井号</span><br><span class="line"><span class="command">\+</span> 加号</span><br><span class="line"><span class="command">\-</span> 减号</span><br><span class="line"><span class="command">\.</span> 英文句号</span><br><span class="line"><span class="command">\!</span> 感叹号</span><br></pre></td></tr></table></figure></p>
<h1 id="其它">其它</h1><p>文本中可直接用html标签，但是要前后加上空行。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">'text</span>'&gt;</span><br></pre></td></tr></table></figure></p>
<input type="text">

<h1 id="one_more_thing：表格">one more thing：表格</h1><p>Markdown的扩展语法，hexo不支持<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> Tables        </span>|<span class="string"> Are           </span>|<span class="string"> Cool  </span>|</span><br><span class="line">|<span class="string"> ------------- </span>|<span class="string">:-------------:</span>|<span class="string"> -----:</span>|</span><br><span class="line">|<span class="string"> col 3 is      </span>|<span class="string"> right-aligned </span>|<span class="string"> $1600 </span>|</span><br><span class="line">|<span class="string"> col 2 is      </span>|<span class="string"> centered      </span>|<span class="string">   $12 </span>|</span><br><span class="line">|<span class="string"> zebra stripes </span>|<span class="string"> are neat      </span>|<span class="string">    $1 </span>|</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h1 id="参考文献">参考文献</h1><ol>
<li><a href="http://ibruce.info/2013/11/26/markdown/" target="_blank" rel="external">Markdown简明语法</a></li>
<li><a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown语法说明</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[MarkDown语法现在越来越常见了，Github的Readme，SegmentFault、Coding、OSChina、简书都要用...]]>
    
    </summary>
    
      <category term="码农必备常识" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%A0%81%E5%86%9C%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
    
      <category term="MarkDown" scheme="http://www.xuanzhangjiong.xyz/categories/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus浅析]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/09/03/EventBus%E6%B5%85%E6%9E%90/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/09/03/EventBus浅析/</id>
    <published>2015-09-03T02:24:11.000Z</published>
    <updated>2015-12-20T02:59:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="一、概述及基本概念">一、概述及基本概念</h1><p>EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。</p>
<p>作为一个消息总线，有三个主要的元素：</p>
<ul>
<li>Event：事件</li>
<li>Subscriber：事件订阅者，接收特定的事件</li>
<li>Publisher:事件发布者，用于通知Subscriber有事件发生</li>
</ul>
<h2 id="Event">Event</h2><p>Event可以是任意类型的对象。</p>
<h2 id="Subscriber">Subscriber</h2><p>在EventBus中，使用约定来指定事件订阅者以简化使用。即所有事件订阅都都是以onEvent开头的函数，具体来说，函数的名字是onEvent，onEventMainThread，onEventBackgroundThread，onEventAsync这四个，这个和ThreadMode有关，后面再说。</p>
<h2 id="Publisher">Publisher</h2><p>可以在任意线程任意位置发送事件，直接调用EventBus的<code>post(Object)</code>方法，可以自己实例化EventBus对象，但一般使用默认的单例就好了：<code>EventBus.getDefault()</code>，根据post函数参数的类型，会自动调用订阅相应类型事件的函数。</p>
<h2 id="ThreadMode">ThreadMode</h2><p>前面说了，Subscriber函数的名字只能是那4个，因为每个事件订阅函数都是和一个<code>ThreadMode</code>相关联的，ThreadMode指定了会调用的函数。有以下四个ThreadMode：</p>
<ul>
<li>PostThread：事件的处理在和事件的发送在相同的进程，所以事件处理时间不应太长，不然影响事件的发送线程，而这个线程可能是UI线程。对应的函数名是onEvent。</li>
<li>MainThread:事件的处理会在UI线程中执行。事件处理时间不能太长，这个不用说的，长了会ANR的，对应的函数名是onEventMainThread。</li>
<li>BackgroundThread：事件的处理会在一个后台线程中执行，对应的函数名是onEventBackgroundThread，虽然名字是BackgroundThread，事件处理是在后台线程，但事件处理时间还是不应该太长，因为如果发送事件的线程是后台线程，会直接执行事件，如果当前线程是UI线程，事件会被加到一个队列中，由一个线程依次处理这些事件，如果某个事件处理时间太长，会阻塞后面的事件的派发或处理。</li>
<li>Async：事件处理会在单独的线程中执行，主要用于在后台线程中执行耗时操作，每个事件会开启一个线程（有线程池），但最好限制线程的数目。</li>
</ul>
<p>根据事件订阅都函数名称的不同，会使用不同的ThreadMode，比如果在后台线程加载了数据想在UI线程显示，订阅者只需把函数命名为onEventMainThread。</p>
<h1 id="二、简单使用">二、简单使用</h1><p>基本的使用步骤就是如下4步。</p>
<p>定义事件类型：<br><code>public class MyEvent {}</code><br>定义事件处理方法：<br><code>public void onEventMainThread</code><br>注册订阅者：<br><code>EventBus.getDefault().register(this)</code><br>发送事件：<br><code>EventBus.getDefault().post(new MyEvent())</code></p>
<h1 id="三、实现">三、实现</h1><p>EventBus使用方法很简单，但用一个东西，如果不了解它的实现用起来心里总是没底，万一出问题咋办都不知道，所以还是研究一下它的实现，肯定要Read the fucking Code。其实主要是<code>EventBus</code>这一个类，在看看Code时需要了解几个概念与成员，了解了这些后实现就很好理解了。</p>
<p>EventType：onEvent函数中的参数，表示事件的类型<br>Subscriber：订阅源，即调用register注册的对象，这个对象内包含onEvent函数<br>SubscribMethod：<code>Subscriber</code>内某一特定的onEvent方法，内部成员包含一个<code>Method</code>类型的method成员表示这个onEvent方法，一个<code>ThreadMode</code>成员threadMode表示事件的处理线程，一个<code>Class&lt;?&gt;</code>类型的eventType成员表示事件的类型<code>EventType</code>。<br>Subscription，表示一个订阅对象，包含订阅源<code>Subscriber</code>，订阅源中的某一特定方法<code>SubscribMethod</code>，这个订阅的优先级<code>priopity</code></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EventType -&gt; List&lt;Subscription&gt;，事件到订阅对象之间的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscriber -&gt; List&lt;EventType&gt;，订阅源到它订阅的的所有事件类型的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;<span class="keyword">Class</span>&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stickEvent事件，后面会看到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventType -&gt; List&lt;? extends EventType&gt;，事件到它的父事件列表的映射。即缓存一个类的所有父类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;<span class="keyword">Class</span>&lt;?&gt;, List&lt;<span class="keyword">Class</span>&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;<span class="keyword">Class</span>&lt;?&gt;, List&lt;<span class="keyword">Class</span>&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="四、注册事件：register">四、注册事件：register</h1><p>通过<code>EventBus.getDefault().register</code>方法可以向<code>EventBus</code>注册来订阅事件，<code>register</code>有很多种重载形式，但大都被标记为<code>Deprecated</code>了，所以还是不用为好，前面说了事件处理方法都是以<em>onEvent</em>开头，其实是可以通过register方法修改的，但相应的方法被废弃了，还是不要用了，就用默认的<em>onEvent</em>，除下废弃的register方法，还有以下4个<strong>public</strong>的<code>register</code>方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span>(subscriber, defaultMethodName, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span>(subscriber, defaultMethodName, <span class="literal">false</span>, priority);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSticky</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span>(subscriber, defaultMethodName, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerSticky</span><span class="params">(Object subscriber, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span>(subscriber, defaultMethodName, <span class="literal">true</span>, priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这4个方法都调用了同一个方法：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">private</span> synchronized void register(Object <span class="keyword">subscriber, </span><span class="keyword">String </span>methodName, <span class="keyword">boolean </span>sticky, int priority) &#123;</span><br><span class="line">    List&lt;<span class="keyword">SubscriberMethod&gt; </span><span class="keyword">subscriberMethods </span>= <span class="keyword">subscriberMethodFinder.findSubscriberMethods(subscriber.getClass(),</span><br><span class="line"></span><span class="label">methodName</span>)<span class="comment">;</span></span><br><span class="line">    for (<span class="keyword">SubscriberMethod </span><span class="keyword">subscriberMethod </span>: <span class="keyword">subscriberMethods) </span>&#123;</span><br><span class="line">        <span class="keyword">subscribe(subscriber, </span><span class="keyword">subscriberMethod, </span>sticky, priority)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个参数就是订阅源，第二个参数就是用到指定方法名约定的，默认为<em>onEvent</em>开头，说默认是其实是可以通过参数修改的，但前面说了，方法已被废弃，最好不要用。第三个参数表示是否是<em>Sticky Event</em>，第4个参数是优先级，这两个后面再说。</p>
<p>在上面这个方法中，使用了一个叫<code>SubscriberMethodFinder</code>的类，通过其<code>findSubscriberMethods</code>方法找到了一个<code>SubscriberMethod</code>列表，前面知道了<code>SubscriberMethod</code>表示Subcriber内一个onEvent方法，可以看出来<code>SubscriberMethodFinder</code>类的作用是在Subscriber中找到所有以methodName（即默认的onEvent）开头的方法，每个找到的方法被表示为一个<code>SubscriberMethod</code>对象。</p>
<p><code>SubscriberMethodFinder</code>就不再分析了，但有两点需要知道：</p>
<p>所有事件处理方法<strong>必需是<code>public void</code>类型</strong>的，并且只有一个参数表示<em>EventType</em>。<br><code>findSubscriberMethods</code>不只查找<em>Subscriber</em>内的事件处理方法，<strong>同时还会查到它的继承体系中的所有基类中的事件处理方法</strong>。<br>找到<em>Subscriber</em>中的所有事件处理方法后，会对每个找到的方法（表示为<code>SubscriberMethod</code>对象）调用<code>subscribe</code>方法注册。<code>subscribe</code>方法干了三件事：</p>
<p>根据<code>SubscriberMethod</code>中的<em>EventType</em>类型将<code>Subscribtion</code>对象存放在<code>subscriptionsByEventType</code>中。建立<em>EventType</em>到<em>Subscription</em>的映射，每个事件可以有多个订阅者。<br>根据<code>Subscriber</code>将<code>EventType</code>存放在<code>typesBySubscriber</code>中，建立<em>Subscriber</em>到<em>EventType</em>的映射，每个Subscriber可以订阅多个事件。<br>如果是<em>Sticky</em>类型的订阅者，直接向它发送上个保存的事件（如果有的话）。<br>通过<em>Subscriber</em>到<em>EventType</em>的映射，我们就可以很方便地使一个Subscriber取消接收事件，通过<em>EventType</em>到<em>Sucscribtion</em>的映射，可以方便地将相应的事件发送到它的每一个订阅者。</p>
<h1 id="五、post事件">五、post事件</h1><p>直接调用<code>EventBus.getDefault().post(Event)</code>就可以发送事件，根据Event的类型就可以发送到相应事件的订阅者。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span>(<span class="params">Object <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.<span class="keyword">get</span>();</span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(<span class="keyword">event</span>);</span><br><span class="line">    <span class="keyword">if</span> (postingState.isPosting) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到post内使用了<code>PostingThreadState</code>的对象，并且是<code>ThreadLocal</code>，来看<code>PostingThreadState</code>的定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="literal">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">Object</span>&gt;();</span><br><span class="line">    boolean isPosting;</span><br><span class="line">    boolean isMainThread;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    <span class="built_in">Object</span> event;</span><br><span class="line">    boolean canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是有个成员<code>eventQueue</code>，由于是ThreadLocal，所以结果就是，每个线程有一个<code>PostingThreadState</code>对象，这个对象内部有一个事件的队列，并且有一个成员<code>isPosting</code>表示现在是否正在派发事件，当发送事件开始时，会依次取出队列中的事件发送出去，如果正在派发事件，那么post直接把事件加入队列后返回，还有个成员<code>isMainThread</code>，这个成员在实际派发事件时会用到，在<code>postSingleEvent</code>中会用到。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> postSingleEvent(Object event, PostingThreadState postingState) <span class="keyword">throws</span> Error &#123;</span><br><span class="line">    <span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Object&gt; eventClass = event.getClass();</span><br><span class="line">    List&lt;<span class="keyword">Class</span>&lt;?&gt;&gt; eventTypes = findEventTypes(eventClass); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> countTypes = eventTypes.<span class="keyword">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">Class</span>&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">        CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            subscriptions = subscriptionsByEventType.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123; <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">                postingState.event = event;</span><br><span class="line">                postingState.subscription = subscription;</span><br><span class="line">                <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    postToSubscription(subscription, event, postingState.isMainThread); <span class="comment">// 4</span></span><br><span class="line">                    aborted = postingState.canceled;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                    postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                    postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            subscriptionFound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        <span class="keyword">if</span> (eventClass != NoSubscriberEvent.<span class="keyword">class</span> &amp;&amp; eventClass != SubscriberExceptionEvent.<span class="keyword">class</span>) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下<code>postSingleEvent</code>这个函数，首先看第一点，调用了<code>findEventTypes</code>这个函数，代码不帖了，这个函数的应用就是，把这个类的类对象、实现的接口及父类的类对象存到一个List中返回.</p>
<p>接下来进入第二步，遍历第一步中得到的List，对List中的每个类对象（即事件类型）执行第三步操作，即找到这个事件类型的所有订阅者向其发送事件。可以看到，<strong>当我们Post一个事件时，这个事件的父事件（事件类的父类的事件）也会被Post，所以如果有个事件订阅者接收Object类型的事件，那么它就可以接收到所有的事件</strong>。</p>
<p>还可以看到，实际是通过第四步中的<code>postToSubscription</code>来发送事件的，在发送前把事件及订阅者存入了<code>postingState</code>中。再来看<code>postToSubscription</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span>(<span class="params">Subscription subscription, Object <span class="keyword">event</span>, boolean isMainThread</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> PostThread:</span><br><span class="line">        invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MainThread:</span><br><span class="line">        <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">            invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mainThreadPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BackgroundThread:</span><br><span class="line">        <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">            backgroundPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeSubscriber(subscription, <span class="keyword">event</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Async:</span><br><span class="line">        asyncPoster.enqueue(subscription, <span class="keyword">event</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就用到<code>ThreadMode</code>了：</p>
<ul>
<li>如果是PostThread，直接执行</li>
<li>如果是MainThread，判断当前线程，如果本来就是UI线程就直接执行，否则加入<code>mainThreadPoster</code>队列</li>
<li>如果是后台线程，如果当前是UI线程，加入<code>backgroundPoster</code>队列，否则直接执行</li>
<li>如果是Async，加入<code>asyncPoster</code>队列</li>
</ul>
<h1 id="六、BackgroundPoster">六、BackgroundPoster</h1><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!executorRunning) &#123;</span><br><span class="line">            executorRunning = <span class="keyword">true</span>;</span><br><span class="line">            EventBus.executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，其实就是，待发送的事件被封装成了<code>PendingPost</code>对象，<code>PendingPostQueue</code>是一个<code>PendingPost</code>对象的队列，当<code>enqueue</code>时就把这个事件放到队列中，<code>BackgroundPoster</code>其实就是一个Runnable对象，当<code>enqueue</code>时，如果这个Runnable对象当前没被执行，就将<code>BackgroundPoster</code>加入EventBus中的一个线程池中，当<code>BackgroundPoster</code>被执行时，会依次取出队列中的事件进行派发。当长时间无事件时<code>BackgroundPoster</code>所属的线程被会销毁，下次再Post事件时再创建新的线程。</p>
<h1 id="七、HandlerPoster">七、HandlerPoster</h1><p><code>mainThreadPoster</code>是一个<code>HandlerPoster</code>对象，<code>HandlerPoster</code>继承自<code>Handler</code>，构造函数中接收一个<code>Looper</code>对象，当向<code>HandlerPoster</code> enqueue事件时，会像<code>BackgroundPoster</code>一样把这个事件加入队列中， 只是如果当前没在派发消息就向自身发送Message</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span>(<span class="params">Subscription subscription, Object <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, <span class="keyword">event</span>);</span><br><span class="line">    synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">            handlerActive = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>handleMessage</code>中会依次取出队列中的消息交由<code>EventBus</code>直接调用事件处理函数，而<code>handleMessage</code>执行所在的线程就是构造函数中传进来的<code>Looper</code>所属的线程，在<code>EventBus</code>中构造<code>mainThreadPoster</code>时传进来的是MainLooper，所以会在UI线程中执行。</p>
<h1 id="八、AsyncPoster">八、AsyncPoster</h1><p><code>AsyncPoster</code>就简单了，把每个事件都加入线程池中处理</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span>(<span class="params">Subscription subscription, Object <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, <span class="keyword">event</span>);</span><br><span class="line">    queue.enqueue(pendingPost);</span><br><span class="line">    EventBus.executorService.execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九、Stick_Event">九、Stick Event</h1><p>通过<code>registerSticky</code>可以注册Stick事件处理函数，前面我们知道了，无论是<code>register</code>还是<code>registerSticky</code>最后都会调用<code>Subscribe</code>函数，在<code>Subscribe</code>中有这么一段代码：</p>
<p>也就是会根据事件类型从<code>stickyEvents</code>中查找是否有对应的事件，如果有，直接发送这个事件到这个订阅者。而这个事件是什么时候存起来的呢，同<code>register</code>与<code>registerSticky</code>一样，和<code>post</code>一起的还有一个<code>postSticky</code>函数：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">    <span class="keyword">Object</span> stickyEvent;</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        stickyEvent = stickyEvents.<span class="built_in">get</span>(eventType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">        <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span></span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当通过<code>postSticky</code>发送一个事件时，这个类型的事件的最后一次事件会被缓存起来，当有订阅者通过<code>registerSticky</code>注册时，会把之前缓存起来的这个事件直接发送给它。</p>
<h1 id="事件优先级priority">事件优先级priority</h1><p><code>register</code>的函数重载中有一个可以指定订阅者的优先级，我们知道<code>EventBus</code>中有一个事件类型到List<subscription>的映射，在这个映射中，所有的Subscription是按priority排序的，这样当post事件时，优先级高的会先得到机会处理事件。</subscription></p>
<p>优先级的一个应用就事，高优先级的事件处理函数可以终于事件的传递，通过<code>cancelEventDelivery</code>方法，但有一点需要注意，<code>这个事件的ThreadMode必须是PostThread</code>，并且只能终于它在处理的事件。</p>
<p>缺点<br>无法进程间通信，如果一个应用内有多个进程的话就没办法了</p>
<p>注意事项及要点<br>同一个onEvent函数不能被注册两次，所以不能在一个类中注册同时还在父类中注册<br>当Post一个事件时，这个事件类的父类的事件也会被Post。<br>Post的事件无Subscriber处理时会Post <code>NoSubscriberEvent</code>事件，当调用Subscriber失败时会Post <code>SubscriberExceptionEvent</code>事件。</p>
<h1 id="其他">其他</h1><p><code>EventBus</code>中还有个Util包，主要作用是可以通过<code>AsyncExecutor</code>执行一个Runnable，通过内部的RunnableEx(可以搜索异常的Runnable)当Runnable抛出异常时通过<code>EventBus</code>发消息显示错误对话框。</p>
]]></content>
    <summary type="html">
    <![CDATA[有空学习了一下EventBus,希望下个项目中可以试用下...]]>
    
    </summary>
    
      <category term="异步事件处理" scheme="http://www.xuanzhangjiong.xyz/tags/%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
      <category term="Android" scheme="http://www.xuanzhangjiong.xyz/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用Git命令清单]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/09/01/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/09/01/常用Git命令清单/</id>
    <published>2015-09-01T13:07:23.000Z</published>
    <updated>2015-12-19T13:48:45.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/常用Git命令清单_1.jpg" alt=""></p>
<p>敲了N遍Git命令，还是很多记住住，今天看了一篇别人总结的Git命令，敲一遍，练练手吧。</p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/常用Git命令清单_2.png" alt=""><br><br></p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h1 id="一、新建代码库">一、新建代码库</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="keyword">clone</span> <span class="title">[url</span>]</span><br></pre></td></tr></table></figure>
<h1 id="二、配置">二、配置</h1><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line"><span class="variable">$ </span>git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line"><span class="variable">$ </span>git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line"><span class="variable">$ </span>git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="三、增加／删除文件">三、增加／删除文件</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line"><span class="variable">$ </span>git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="variable">$ </span>git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="variable">$ </span>git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="variable">$ </span>git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="variable">$ </span>git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<h1 id="四、代码提交">四、代码提交</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git <span class="operator"><span class="keyword">commit</span> -<span class="keyword">m</span> [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git <span class="keyword">commit</span> [file1] [file2] ... -<span class="keyword">m</span> [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次<span class="keyword">commit</span>之后的变化，直接到仓库区</span><br><span class="line">$ git <span class="keyword">commit</span> -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git <span class="keyword">commit</span> -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的<span class="keyword">commit</span>，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次<span class="keyword">commit</span>的提交信息</span><br><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend -m [message]</span></span><br><span class="line"></span><br><span class="line"># 重做上一次<span class="keyword">commit</span>，并包括指定文件的新变化</span><br><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend [file1] [file2] ...</span></span></span><br></pre></td></tr></table></figure>
<h1 id="五、分支">五、分支</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line"><span class="variable">$ </span>git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="variable">$ </span>git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="variable">$ </span>git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="variable">$ </span>git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="variable">$ </span>git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="variable">$ </span>git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="variable">$ </span>git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line"><span class="variable">$ </span>git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="variable">$ </span>git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line"><span class="variable">$ </span>git push origin --delete [branch-name]</span><br><span class="line"><span class="variable">$ </span>git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
<h1 id="六、标签">六、标签</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line"></span><br><span class="line"><span class="title"># 新建一个tag</span>在当前commit</span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [<span class="operator">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [<span class="operator">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [<span class="operator">tag</span>]</span><br></pre></td></tr></table></figure>
<h1 id="七、查看信息">七、查看信息</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line"><span class="variable">$ </span>git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line"><span class="variable">$ </span>git log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="variable">$ </span>git log --stat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="variable">$ </span>git log --follow [file]</span><br><span class="line"><span class="variable">$ </span>git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="variable">$ </span>git log -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="variable">$ </span>git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff <span class="constant">HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line"><span class="variable">$ </span>git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="variable">$ </span>git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="variable">$ </span>git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="variable">$ </span>git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="variable">$ </span>git reflog</span><br></pre></td></tr></table></figure>
<h1 id="八、远程同步">八、远程同步</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line"><span class="variable">$ </span>git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line"><span class="variable">$ </span>git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="variable">$ </span>git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="variable">$ </span>git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line"><span class="variable">$ </span>git push [remote] --all</span><br></pre></td></tr></table></figure>
<h1 id="九、撤销">九、撤销</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个<span class="operator"><span class="keyword">commit</span>的指定文件到工作区</span><br><span class="line">$ git checkout [<span class="keyword">commit</span>] [<span class="keyword">file</span>]</span><br><span class="line"></span><br><span class="line"># 恢复上一个<span class="keyword">commit</span>的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次<span class="keyword">commit</span>保持一致，但工作区不变</span><br><span class="line">$ git <span class="keyword">reset</span> [<span class="keyword">file</span>]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次<span class="keyword">commit</span>保持一致</span><br><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard</span></span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定<span class="keyword">commit</span>，同时重置暂存区，但工作区不变</span><br><span class="line">$ git <span class="keyword">reset</span> [<span class="keyword">commit</span>]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的<span class="keyword">HEAD</span>为指定<span class="keyword">commit</span>，同时重置暂存区和工作区，与指定<span class="keyword">commit</span>一致</span><br><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard [commit]</span></span><br><span class="line"></span><br><span class="line"># 重置当前<span class="keyword">HEAD</span>为指定<span class="keyword">commit</span>，但保持暂存区和工作区不变</span><br><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--keep [commit]</span></span><br><span class="line"></span><br><span class="line"># 新建一个<span class="keyword">commit</span>，用来撤销指定<span class="keyword">commit</span></span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [<span class="keyword">commit</span>]</span></span><br></pre></td></tr></table></figure>
<h1 id="十、其他">十、其他</h1><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line"><span class="variable">$ </span>git archive</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[看到别人写的挺好的，拿来敲一边，就当回顾总结吧，哈哈，太机智了...]]>
    
    </summary>
    
      <category term="码农必备常识" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%A0%81%E5%86%9C%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
    
      <category term="Git" scheme="http://www.xuanzhangjiong.xyz/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git Flow简介]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/08/09/Git-Flow%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/08/09/Git-Flow简介/</id>
    <published>2015-08-09T08:37:14.000Z</published>
    <updated>2015-12-09T09:31:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="关于">关于</h1><p>git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。<br>这里，我介绍下它的简单用法。<br>当然，我也只会这么一点点小技巧。</p>
<h1 id="安装">安装</h1><p>第一步当然，你必须要有一个git环境咯，我就不啰嗦了。<br>Mac下，有2种安装方式：<br>Homebrew:</p>
<p><code>brew install git-flow</code></p>
<p>Macports:</p>
<p><code>port install git-flow</code></p>
<p>没有上面两个包管理的童鞋自行GitHub吧。</p>
<h1 id="开始">开始</h1><p>为了自定义你的项目，Git flow需要初始化过程。<br>初始化<br>使用 git-flow，从初始化一个现有的 git 库内开始:</p>
<p><code>git flow init</code></p>
<p>你必须回答几个关于分支的命名约定的问题。<br>建议使用默认值。</p>
<h1 id="特性">特性</h1><p>为即将发布的版本开发新功能特性。<br>这通常只存在开发者的库中。</p>
<h2 id="增加新特性">增加新特性</h2><p>新特性的开发是基于 ‘develop’ 分支的。<br>通过下面的命令开始开发新特性：</p>
<p><code>git flow feature start MYFEATURE</code></p>
<p>这个操作创建了一个基于’develop’的特性分支，并切换到这个分支之下。</p>
<h2 id="完成新特性">完成新特性</h2><p>完成开发新特性。这个动作执行下面的操作。<br>合并 MYFEATURE 分支到 ‘develop’<br>删除这个新特性分支<br>切换回 ‘develop’ 分支</p>
<p><code>git flow feature finish MYFEATURE</code></p>
<h2 id="发布新特性">发布新特性</h2><p>你是否合作开发一项新特性？<br>发布新特性分支到远程服务器，所以，其它用户也可以使用这分支。</p>
<p><code>git flow feature publish MYFEATURE</code></p>
<h2 id="取得一个发布的新特性分支">取得一个发布的新特性分支</h2><p>取得其它用户发布的新特性分支，并签出远程的变更。</p>
<p><code>git flow feature pull MYFEATURE</code></p>
<h1 id="作一个release版本">作一个release版本</h1><p>支持一个新的用于生产环境的发布版本。<br>允许修正小问题，并为发布版本准备元数据。</p>
<h2 id="开始准备release版本">开始准备release版本</h2><p>开始准备release版本，使用 git flow release 命令.<br>它从 ‘develop’ 分支开始创建一个 release 分支。</p>
<p><code>git flow release start RELEASE [BASE]</code></p>
<p>你可以选择提供一个 [BASE]参数，即提交记录的 sha-1 hash 值，来开启动 release 分支. 这个提交记录的 sha-1 hash 值必须是’develop’ 分支下的。<br>创建 release 分支之后立即发布允许其它用户向这个 release 分支提交内容是个明智的做法。命令十分类似发布新特性：</p>
<p><code>git flow release publish RELEASE</code></p>
<p>(你可以通过 <code>git flow release track RELEASE</code>命令签出 release 版本的远程变更)</p>
<h2 id="完成release版本">完成release版本</h2><p>完成 release 版本是一个大 git 分支操作。它执行下面几个动作：<br>归并 release 分支到 ‘master’ 分支<br>用 release 分支名打 Tag<br>归并 release 分支到 ‘develop’<br>移除 release 分支</p>
<p><code>git flow release finish RELEASE</code></p>
<h1 id="紧急修复">紧急修复</h1><p>紧急修复来自这样的需求：生产环境的版本处于一个不预期状态，需要立即修正。<br>有可能是需要修正 master 分支上某个 TAG 标记的生产版本。</p>
<h2 id="开始git_flow紧急修复">开始git flow紧急修复</h2><p>像其它 git flow 命令一样, 紧急修复分支开始自：</p>
<p><code>git flow hotfix start VERSION [BASENAME]</code></p>
<p>VERSION 参数标记着修正版本。你可以从 [BASENAME]开始，[BASENAME]为finish release时填写的版本号</p>
<h2 id="完成紧急修复">完成紧急修复</h2><p>当完成紧急修复分支，代码归并回 develop 和 master 分支。相应地，master 分支打上修正版本的 TAG。</p>
<p><code>git flow hotfix finish VERSION</code></p>
]]></content>
    <summary type="html">
    <![CDATA[简化Git操作的神器]]>
    
    </summary>
    
      <category term="码农必备常识" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%A0%81%E5%86%9C%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
    
      <category term="Git" scheme="http://www.xuanzhangjiong.xyz/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[偶遇Git]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/07/29/%E5%81%B6%E9%81%87Git/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/07/29/偶遇Git/</id>
    <published>2015-07-29T11:26:41.000Z</published>
    <updated>2015-12-09T08:42:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="吐槽">吐槽</h1><p>说起Git，在很久以前就认识它，但是仅仅是知道它的存在，却从未和它交流过。</p>
<p>本科的时候，一直使用svn，而且是TortoiseGit，就是那只传说中的小乌龟，可视化的界面，导致我从来不用bash。</p>
<p>前段时间，跟着导师做一个创业项目，在做前期准备的时候，一句你们用过Git嘛，我的学生Git是一项必备技能。顿时好尴尬，只好硬着头皮说学过一点。然后就是不停地看各种blog。</p>
<p>前前后后也学习了一段时间，来写写自己学习Git的理解吧。</p>
<h1 id="三种状态">三种状态</h1><p>首先要理解你的本地仓库由git维护的三棵“树”组成。第一个是你的工作目录，它持有实际文件；第二个是缓存区（Index）它像个缓存区，临时保存你的改动；最后是HEAD，指向你最近一次提交后的结果。</p>
<blockquote>
<p>WorkingDirectory Index HEAD 三大状态，对理解Git工作原理很有帮助。</p>
</blockquote>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/git_1.jpg" alt="三种状态" title="三种状态"></p>
<h1 id="检出仓库">检出仓库</h1><p>执行如下命令以创建一个本地仓库的克隆版本<br><code>git clone /path/to/repository</code><br>如果是远端服务器上的仓库，你的命令会是这个样子：<br><code>git clone username@host:/path/to/repository</code></p>
<h1 id="添加与提交">添加与提交</h1><p>你可以计划改动（把它们添加到缓存区），使用如下命令：<br><code>git add &lt;filename&gt;</code><br><code>add *</code><br><code>add .</code><br>这是git基本工作流程的第一步；使用如下命令以实际提交改动：<br><code>git commit -m&quot;代码提交信息&quot;</code><br>现在，你的改动已经提交到了HEAD，但是还没到你的远端仓库。</p>
<h1 id="推送改动">推送改动</h1><p>你的改动现在已经在本地仓库的HEAD中了。执行如下命令以将这些改动提交到远端仓库：<br><code>git push origin master</code><br>可以把master换成你想要推送的任何分支。</p>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：<br><code>git remote add origin &lt;server&gt;</code><br>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
<h1 id="分支">分支</h1><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。<br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/git_2.jpg" alt=""><br>创建一个叫做“feature_x”的分支，并且换过去：<br><code>git checkout -b feature_x</code><br>切换回主分支：<br><code>git checkout master</code><br>再把新建的分支删掉:<br><code>git branch -d feature_x</code><br>除非你将分支推送到远端仓库，不然该分支就是不为他人所见的：<br><code>git push origin &lt;branch&gt;</code></p>
<h1 id="更新与合并">更新与合并</h1><p>要更新你的本地仓库至最新改动，执行：<br><code>git pull</code><br>以在你的工作目录中获取（fetch）并合并（merge）远端的改动。<br>要合并其他分支到你的当前分支（例如master），执行：<br><code>git merge &lt;branch&gt;</code><br>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致冲突（conflicts）。这时候就需要你修改这些文件来人肉合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记合并成功：<br><code>git add &lt;filename&gt;</code><br>在合并改动之前，也可以使用如下命令查看：<br><code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p>
<h1 id="标签">标签</h1><p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签：<br><code>git tag 1.0.0 1b2e1d63ff</code><br>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：<br><code>git log</code><br>你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。</p>
<h1 id="替换本地改动">替换本地改动</h1><p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：<br><code>git checkout -- &lt;filename&gt;</code><br>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p>
<p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：<br><code>git fetch origin</code><br><code>git reset --hard origin/master</code></p>
<h1 id="有用的贴士">有用的贴士</h1><p>内建的图形化 git：<br><code>gitk</code><br>彩色的 git 输出：<br><code>git config color.ui true</code><br>显示历史记录时，只显示一行注释信息：<br><code>git config format.pretty oneline</code><br>交互地添加文件至缓存区：<br><code>git add -i</code><br><img src="http://7xoz2q.com1.z0.glb.clouddn.com/git_3.jpg" alt=""></p>
<h1 id="链接与资源">链接与资源</h1><h2 id="图形化界面">图形化界面</h2><p><code>GitX (L) (OSX, open source)``
</code>Tower (OSX)<code>`
</code>Source Tree (OSX, free)<code>`GitHub for Mac (OSX, free)</code><br><code>GitBox (OSX)</code></p>
<h2 id="指南与手册">指南与手册</h2><p><a href="http://git-scm.com/book/en/v2" target="_blank" rel="external">Git 社区参考书</a><br><a href="http://git-scm.com/book/en/v2" target="_blank" rel="external">专业 Git</a><br><a href="http://think-like-a-git.net/" target="_blank" rel="external">如 git 思考</a><br><a href="https://help.github.com/" target="_blank" rel="external">GitHub 帮助</a><br><a href="http://marklodato.github.io/visual-git-guide/index-en.html" target="_blank" rel="external">图形化的 Git 指南一则</a></p>
<h1 id="自认为比较好的Git学习教材">自认为比较好的Git学习教材</h1><ul>
<li><a href="https://www.atlassian.com/git/tutorials/" target="_blank" rel="external">https://www.atlassian.com/git/tutorials/</a></li>
<li><a href="http://git.oschina.net/progit/" target="_blank" rel="external">http://git.oschina.net/progit/</a></li>
<li><a href="http://www.cnblogs.com/whthomas/p/4564906.html" target="_blank" rel="external">http://www.cnblogs.com/whthomas/p/4564906.html</a></li>
<li><a href="http://www.imooc.com/article/1426" target="_blank" rel="external">http://www.imooc.com/article/1426</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[学会Git才发现自己是一个混迹互联网的coder]]>
    
    </summary>
    
      <category term="码农必备常识" scheme="http://www.xuanzhangjiong.xyz/tags/%E7%A0%81%E5%86%9C%E5%BF%85%E5%A4%87%E5%B8%B8%E8%AF%86/"/>
    
      <category term="Git" scheme="http://www.xuanzhangjiong.xyz/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MVC、MVP、MVVM的个人理解]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/07/15/MVC%E3%80%81MVP%E3%80%81MVVM%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/07/15/MVC、MVP、MVVM的个人理解/</id>
    <published>2015-07-15T12:32:08.000Z</published>
    <updated>2015-12-19T13:05:54.000Z</updated>
    <content type="html"><![CDATA[<p>从最初的只要把功能实现出来可以不择手段，到代码太乱了，整理整理吧，再到看看别人写的代码，那就把每个类分分类吧。嗯，再看看那些开源的项目，自己不得不开始思考系统架构了，因为，它就好比代码中的书法，然而它比书法更重要，因为，有一个好的架构不仅可以使得项目更加便于阅读，理解，甚至在有些时候执行效率也更好，so…..</p>
<p>MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。</p>
<h1 id="一、MVC">一、MVC</h1><p>MVC模式的意思是，软件可以分成三个部分。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_1.png" alt=""></p>
<ul>
<li>视图（View）：用户界面。</li>
<li>控制器（Controller）：业务逻辑</li>
<li>模型（Model）：数据保存<br><br></li>
</ul>
<hr>
<p>各部分之间的通信方式如下。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_2.png" alt=""></p>
<ol>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ol>
<p>所有通信都是单向的。</p>
<h1 id="二、互动模式">二、互动模式</h1><p>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_3.png" alt=""></p>
<p>另一种是直接通过controller接受指令。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_4.png" alt=""></p>
<h1 id="三、实例：Backbone">三、实例：Backbone</h1><p>但是实际项目往往采取更加灵活的方式，以 Backbone.js 为例。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvc_5.png" alt=""></p>
<ol>
<li>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</li>
<li>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</li>
<li>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</li>
</ol>
<h1 id="四、MVP">四、MVP</h1><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvp.png" alt=""></p>
<ol>
<li>各部分之间的通信，都是双向的。</li>
<li>View 与 Model 不发生联系，都通过 Presenter 传递。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
</ol>
<h1 id="五、MVVM">五、MVVM</h1><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p>
<p><img src="http://7xoz2q.com1.z0.glb.clouddn.com/mvvm.png" alt=""></p>
<p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p>
]]></content>
    <summary type="html">
    <![CDATA[对3种系统架构的浅显理解]]>
    
    </summary>
    
      <category term="常见3种架构" scheme="http://www.xuanzhangjiong.xyz/tags/%E5%B8%B8%E8%A7%813%E7%A7%8D%E6%9E%B6%E6%9E%84/"/>
    
      <category term="架构" scheme="http://www.xuanzhangjiong.xyz/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开篇]]></title>
    <link href="http://www.xuanzhangjiong.xyz/2015/06/20/%E5%BC%80%E7%AF%87/"/>
    <id>http://www.xuanzhangjiong.xyz/2015/06/20/开篇/</id>
    <published>2015-06-20T11:50:11.000Z</published>
    <updated>2015-12-07T08:56:27.000Z</updated>
    <content type="html"><![CDATA[<p>今天很开心，因为毕业了～！！！可以有时间好好学习自己想学的东西，专心做一个coder。</p>
<h1 id="简介">简介</h1><p>前一段时间，了解了一些搭建个人博客的方法，比较起来，hexo在我眼里秒杀一切，或许是由于我对<a href="http://www.nodejs.org" target="_blank" rel="external">node</a>中毒太深吧。</p>
<p>在阿里云上买了一个域名＋<a href="https://pages.github.com" target="_blank" rel="external">GitHub Pages</a>＋<a href="https://hexo.io" target="_blank" rel="external">Hexo</a>,以成本价4RMB的价格搭建了我的<a href="http://www.xuanzhangjiong.xyz">blog</a>。<br>大家如果也希望搭建自己的blog的话，看几篇教程，没有发现特别完整的，我也是看了n篇，然后把<a href="https://hexo.io" target="_blank" rel="external">https://hexo.io</a>上的DOCS看完，选一个自己心仪的主题，定制成自己喜欢的风格，然后就可以开始自己的blog之路了。<br>对了如果你的blog中图片太多的话，建议你用七牛云存储，不是帮他们打广告哈，只是没有CDN加速，访问效率可能真的真的…<br>这是我的邀请链接：<a href="https://portal.qiniu.com/signup?code=3ll21mpkdin2q" target="_blank" rel="external">https://portal.qiniu.com/signup?code=3ll21mpkdin2q</a>，好人一生平安，嘻嘻。</p>
<h1 id="定位">定位</h1><p>我喜欢移动开发，擅长Android开发，但也不乏对iOS、Javascript全栈有着浓厚的兴趣，虽然现在只是个菜，但是希望以后能成为一颗大白菜。也许有人会说以后以后只会从事一个方向的工作，何必学着么多呢，我也曾想过，坚持下去的理由却很简单：喜欢就好，何必在乎这么多呢。所以以后我的blog的定位也是：</p>
<blockquote>
<p>Android<br>iOS<br>Web前端<br>Git<br>Node.js</p>
</blockquote>
<p>边学习边分享吧，大家共同进步。</p>
<h1 id="初衷">初衷</h1><p>写博客只为记录自己的开发历程，希望自己在这个互联网时代中留下一些自己的足迹，证明自己也曾为开源做过贡献。</p>
]]></content>
    <summary type="html">
    <![CDATA[磨蹭了几个月的blog终于开篇了]]>
    
    </summary>
    
      <category term="毕业季" scheme="http://www.xuanzhangjiong.xyz/tags/%E6%AF%95%E4%B8%9A%E5%AD%A3/"/>
    
      <category term="生活小记" scheme="http://www.xuanzhangjiong.xyz/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
